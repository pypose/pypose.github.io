


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pypose.lietensor.utils &mdash; PyPose main documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <!-- <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" /> -->
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/katex-math.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex/" />
    <link rel="search" title="Search" href="../../../../search/" />

<!--
  Search engines should not index the master version of documentation.
  Stable documentation are built without release == 'main'.
-->
<meta name="robots" content="noindex">


  <!-- Google Analytics -->
  
  <!-- End Google Analytics -->
  


  
  <script src="../../../../_static/js/modernizr.min.js"></script>

  <!-- Preload the theme fonts -->

<link rel="preload" href="../../../../_static/fonts/FreightSans/freight-sans-book.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/FreightSans/freight-sans-medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/IBMPlexMono/IBMPlexMono-Medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/FreightSans/freight-sans-bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/FreightSans/freight-sans-medium-italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/IBMPlexMono/IBMPlexMono-SemiBold.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<!-- Preload the katex fonts -->

<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Math-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size1-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size4-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size2-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size3-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Caligraphic-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css" integrity="sha384-vSIIfh2YWi9wW0r9iZe7RJPrKwp6bG+s9QZMoITbCckVJqGCCRhc+ccxNcdpHuYu" crossorigin="anonymous">
</head>

<div class="container-fluid header-holder tutorials-header" id="header-holder">
  <div class="container">
    <div class="header-container">
      <a class="header-logo" href="https://pypose.org/" aria-label="PyTorch"></a>

      <div class="main-menu">
        <ul>
          <li>
            <a href="https://pypose.org/get-started">Get Started</a>
          </li>

          <!-- <li> -->
          <li>
            <a href="https://pypose.org/tutorials">Tutorials</a>
          </li>

          <!-- <li class="active docs-active"> -->
          <li>
            <a href="https://pypose.org/docs/main/index.html">Doc</a>
          </li>

          <li>
            <a href="https://pypose.org/about-us">About Us</a>
          </li>

          <li>
            <a href="https://github.com/pypose/pypose">GitHub</a>
          </li>
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
    </div>
  </div>
</div>

<body class="pytorch-body">

   

    

    <div class="table-of-contents-link-wrapper">
      <span>Table of Contents</span>
      <a href="#" class="toggle-table-of-contents" data-behavior="toggle-table-of-contents"></a>
    </div>

    <nav data-toggle="wy-nav-shift" class="pytorch-left-menu" id="pytorch-left-menu">
      <div class="pytorch-side-scroll">
        <div class="pytorch-menu pytorch-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          <div class="pytorch-left-menu-search">
            
    <div class="version">
      <a href='https://pypose.org/docs/versions.html'>0.2.0 &#x25BC</a>
    </div>
    


  


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search/" method="get">
    <input type="text" name="q" placeholder="Search Docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          </div>

          

<div>
  <a style="color:#F05732" href="_modules/pypose/lietensor/utils.html">
    You are viewing unstable developer preview docs.
    Click here to view docs for latest stable release.
  </a>
</div>


            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../lietensor/">LieTensor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../basics/">Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../convert/">Convert</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules/">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../optim/">Optimization</a></li>
</ul>

            
          

        </div>
      </div>
    </nav>

    <div class="pytorch-container">
      <div class="pytorch-page-level-bar" id="pytorch-page-level-bar">
        <div class="pytorch-breadcrumbs-wrapper">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="pytorch-breadcrumbs">
    
      <li>
        <a href="../../../../">
          
            Docs
          
        </a> &gt;
      </li>

        
          <li><a href="../../../">Module code</a> &gt;</li>
        
      <li>pypose.lietensor.utils</li>
    
    
      <li class="pytorch-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
</div>
        </div>

        <div class="pytorch-shortcuts-wrapper" id="pytorch-shortcuts-wrapper">
          Shortcuts
        </div>
      </div>

      <section data-toggle="wy-nav-shift" id="pytorch-content-wrap" class="pytorch-content-wrap">
        <div class="pytorch-content-left">

        
          
          <div class="rst-content">
          
            <div role="main" class="main-content" itemscope="itemscope" itemtype="http://schema.org/Article">
             <article itemprop="articleBody" id="pytorch-article" class="pytorch-article">
              
  <h1>Source code for pypose.lietensor.utils</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">torch</span><span class="o">,</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">.lietensor</span> <span class="kn">import</span> <span class="n">LieTensor</span><span class="p">,</span> <span class="n">LieType</span>
<span class="kn">from</span> <span class="nn">.lietensor</span> <span class="kn">import</span> <span class="n">SE3_type</span><span class="p">,</span> <span class="n">se3_type</span>
<span class="kn">from</span> <span class="nn">.lietensor</span> <span class="kn">import</span> <span class="n">SO3_type</span><span class="p">,</span> <span class="n">so3_type</span>
<span class="kn">from</span> <span class="nn">.lietensor</span> <span class="kn">import</span> <span class="n">Sim3_type</span><span class="p">,</span> <span class="n">sim3_type</span>
<span class="kn">from</span> <span class="nn">.lietensor</span> <span class="kn">import</span> <span class="n">RxSO3_type</span><span class="p">,</span> <span class="n">rxso3_type</span>


<span class="k">def</span> <span class="nf">_LieTensor_wrapper_add_docstr</span><span class="p">(</span><span class="n">wrapper</span><span class="p">:</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">,</span> <span class="n">embedding_doc</span><span class="p">):</span>
    <span class="n">ltype</span><span class="p">:</span> <span class="n">LieType</span> <span class="o">=</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">keywords</span><span class="p">[</span><span class="s1">&#39;ltype&#39;</span><span class="p">]</span>
    <span class="n">type_name</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">ltype</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">type_dim</span> <span class="o">=</span> <span class="n">ltype</span><span class="o">.</span><span class="n">dimension</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">see_method</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Exp&#39;</span><span class="p">,</span> <span class="s1">&#39;Inv&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">ltype</span><span class="o">.</span><span class="n">on_manifold</span> <span class="k">else</span> \
        <span class="p">[</span><span class="s1">&#39;Log&#39;</span><span class="p">,</span> <span class="s1">&#39;Inv&#39;</span><span class="p">,</span> <span class="s1">&#39;Act&#39;</span><span class="p">,</span> <span class="s1">&#39;Retr&#39;</span><span class="p">,</span> <span class="s1">&#39;Adj&#39;</span><span class="p">,</span> <span class="s1">&#39;AdjT&#39;</span><span class="p">,</span> <span class="s1">&#39;Jinvp&#39;</span><span class="p">]</span>
    <span class="n">wrapper</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="sa">fr</span><span class="s1">&#39;&#39;&#39;Alias of </span><span class="si">{</span><span class="n">type_name</span><span class="si">}</span><span class="s1"> type :obj:`LieTensor`.</span>

<span class="s1">    Args:</span>
<span class="s1">        data (:obj:`Tensor`, or :obj:`list`, or &#39;:obj:`int`...&#39;): A</span>
<span class="s1">            :obj:`Tensor` object, or constructing a :obj:`Tensor`</span>
<span class="s1">            object from :obj:`list`, which defines tensor data (see below), or</span>
<span class="s1">            from &#39;:obj:`int`...&#39;, which defines tensor shape.</span>

<span class="s1">            The shape of :obj:`Tensor` object must be ``(*, </span><span class="si">{</span><span class="n">type_dim</span><span class="si">}</span><span class="s1">)``,</span>
<span class="s1">            where ``*`` is empty, one, or more batched dimensions (the</span>
<span class="s1">            :obj:`~LieTensor.lshape` of this LieTensor), otherwise error will</span>
<span class="s1">            be raised.</span>

<span class="s1">    </span><span class="si">{</span><span class="n">embedding_doc</span><span class="si">}</span><span class="s1"></span>

<span class="s1">    If ``data`` is tensor-like, the last dimension should correspond to the</span>
<span class="s1">    </span><span class="si">{</span><span class="n">type_dim</span><span class="si">}</span><span class="s1"> elements of the above embedding.</span>

<span class="s1">    Note:</span>
<span class="s1">        It is not advised to construct </span><span class="si">{</span><span class="n">type_name</span><span class="si">}</span><span class="s1"> Tensors by specifying storage</span>
<span class="s1">        sizes with &#39;:obj:`int`...&#39;, which does not initialize data.</span>

<span class="s1">        Consider using :obj:`pypose.randn_</span><span class="si">{</span><span class="n">type_name</span><span class="si">}</span><span class="s1">` or</span>
<span class="s1">        :obj:`pypose.identity_</span><span class="si">{</span><span class="n">type_name</span><span class="si">}</span><span class="s1">` instead.</span>

<span class="s1">    See </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;:obj:`pypose.</span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s1">`&#39;</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">see_method</span><span class="p">])</span><span class="si">}</span><span class="s1"> for</span>
<span class="s1">    implementations of relevant operations.</span>
<span class="s1">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="n">SO3</span> <span class="o">=</span> <span class="n">_LieTensor_wrapper_add_docstr</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">LieTensor</span><span class="p">,</span> <span class="n">ltype</span><span class="o">=</span><span class="n">SO3_type</span><span class="p">),</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;Internally, SO3 LieTensors are stored as unit quaternions:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{data}[*, :] = [q_x, q_y, q_z, q_w],</span>

<span class="sd">    where :math:`q_x^2 + q_y^2 + q_z^2 + q_w^2 = 1`.</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        Normalization is not required at initialization as it is done internally</span>
<span class="sd">        by the library right before further computation. However, the normalized</span>
<span class="sd">        quaternion will not be written back to the tensor storage to prevent</span>
<span class="sd">        in-place data alteration.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; pp.SO3(torch.randn(2, 4))</span>
<span class="sd">        SO3Type LieTensor:</span>
<span class="sd">        tensor([[-1.0722, -0.9440,  0.9437, -0.8485],</span>
<span class="sd">                [-0.2725,  0.8414, -1.0730,  1.3270]])</span>
<span class="sd">        &gt;&gt;&gt; pp.SO3([0, 0, 0, 1])</span>
<span class="sd">        SO3Type LieTensor:</span>
<span class="sd">        tensor([0., 0., 0., 1.])</span>
<span class="sd">    &#39;&#39;&#39;</span><span class="p">)</span>

<span class="n">so3</span> <span class="o">=</span> <span class="n">_LieTensor_wrapper_add_docstr</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">LieTensor</span><span class="p">,</span> <span class="n">ltype</span><span class="o">=</span><span class="n">so3_type</span><span class="p">),</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;Internally, so3 LieTensors are stored in the</span>
<span class="sd">    `axis-angle &lt;https://en.wikipedia.org/wiki/Axis-angle_representation&gt;`_ format:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{data}[*, :] = [\delta_x, \delta_y, \delta_z],</span>

<span class="sd">    with :math:`\delta = \begin{pmatrix} \delta_x &amp; \delta_y &amp; \delta_z \end{pmatrix}\top`</span>
<span class="sd">    being the axis of rotation and :math:`\theta = \|{\delta}\|` being the angle.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; pp.so3(torch.randn(2, 3))</span>
<span class="sd">        so3Type LieTensor:</span>
<span class="sd">        tensor([[ 0.1571,  0.2203, -0.2457],</span>
<span class="sd">                [-0.3311,  0.5412, -0.7028]])</span>
<span class="sd">        &gt;&gt;&gt; pp.so3([0, 0, 1])</span>
<span class="sd">        so3Type LieTensor:</span>
<span class="sd">        tensor([0., 0., 1.])</span>
<span class="sd">    &#39;&#39;&#39;</span><span class="p">)</span>

<span class="n">SE3</span> <span class="o">=</span> <span class="n">_LieTensor_wrapper_add_docstr</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">LieTensor</span><span class="p">,</span> <span class="n">ltype</span><span class="o">=</span><span class="n">SE3_type</span><span class="p">),</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;Internally, SE3 LieTensors are stored by concatenating the unit quaternion</span>
<span class="sd">    representing the rotation with a vector representing the translation.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{data}[*, :] = [t_x, t_y, t_z, q_x, q_y, q_z, q_w],</span>

<span class="sd">    where :math:`\begin{pmatrix} t_x &amp; t_y &amp; t_z \end{pmatrix}\top \in \mathbb{R}^3` is</span>
<span class="sd">    the translation and</span>
<span class="sd">    :math:`\begin{pmatrix} q_x &amp; q_y &amp; q_z &amp; q_w \end{pmatrix}\top` is the unit</span>
<span class="sd">    quaternion as in :obj:`pypose.SO3`.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; pp.SE3(torch.randn(2, 7))</span>
<span class="sd">        SE3Type LieTensor:</span>
<span class="sd">        tensor([[ 0.1626,  1.6349,  0.3607,  0.2848, -0.0948,  0.1541,  1.0003],</span>
<span class="sd">                [ 1.4034, -1.3085, -0.8886, -1.6703,  0.7381,  1.5575,  0.6280]])</span>
<span class="sd">        &gt;&gt;&gt; pp.SE3([0, 0, 0, 0, 0, 0, 1])</span>
<span class="sd">        SE3Type LieTensor:</span>
<span class="sd">        tensor([0., 0., 0., 0., 0., 0., 1.])</span>
<span class="sd">    &#39;&#39;&#39;</span><span class="p">)</span>

<span class="n">se3</span> <span class="o">=</span> <span class="n">_LieTensor_wrapper_add_docstr</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">LieTensor</span><span class="p">,</span> <span class="n">ltype</span><span class="o">=</span><span class="n">se3_type</span><span class="p">),</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;Internally, se3 LieTensors are stored by concatenating the &quot;velocity&quot; vector</span>
<span class="sd">    with the axis-angle representation of the rotation:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{data}[*, :] = [\tau_x, \tau_y, \tau_z, \delta_x, \delta_y, \delta_z],</span>

<span class="sd">    where :math:`\begin{pmatrix} \tau_x &amp; \tau_y &amp; \tau_z \end{pmatrix}^T =</span>
<span class="sd">    \mathbf{J}^{-1} \begin{pmatrix} t_x &amp; t_y &amp; t_z \end{pmatrix}^T` is the product</span>
<span class="sd">    between the left Jacobian inverse (of SO3&#39;s logarithm map) and the translation</span>
<span class="sd">    vector, and :math:`\begin{pmatrix} \delta_x &amp; \delta_y &amp; \delta_z \end{pmatrix}^T`</span>
<span class="sd">    is the axis-angle vector as in :obj:`pypose.so3`.</span>
<span class="sd">    More details go to :meth:`pypose.Log` with :obj:`SE3_type` input.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; pp.se3(torch.randn(2, 6))</span>
<span class="sd">        se3Type LieTensor:</span>
<span class="sd">        tensor([[-0.8710, -1.4994, -0.2843,  1.0185, -0.3932, -0.4839],</span>
<span class="sd">                [-0.4750, -0.4804, -0.7083, -1.8141, -1.4409, -0.3125]])</span>
<span class="sd">        &gt;&gt;&gt; pp.se3([0, 0, 0, 0, 0, 1])</span>
<span class="sd">        se3Type LieTensor:</span>
<span class="sd">        tensor([0., 0., 0., 0., 0., 1.])</span>
<span class="sd">    &#39;&#39;&#39;</span><span class="p">)</span>

<span class="n">RxSO3</span> <span class="o">=</span> <span class="n">_LieTensor_wrapper_add_docstr</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">LieTensor</span><span class="p">,</span> <span class="n">ltype</span><span class="o">=</span><span class="n">RxSO3_type</span><span class="p">),</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;Internally, RxSO3 LieTensors are stored by concatenating the unit quaternion</span>
<span class="sd">    representing the rotation with a scaling factor:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{data}[*, :] = [q_x, q_y, q_z, q_w, s],</span>

<span class="sd">    where :math:`\begin{pmatrix} q_x &amp; q_y &amp; q_z &amp; q_w \end{pmatrix}^T`</span>
<span class="sd">    is the unit quaternion as in :obj:`pypose.SO3` and</span>
<span class="sd">    :math:`s \in \mathbb{R}` is the scaling factor.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; pp.RxSO3(torch.randn(2, 5))</span>
<span class="sd">        RxSO3Type LieTensor:</span>
<span class="sd">        tensor([[-0.3693,  2.5155, -0.5384, -0.8119, -0.4798],</span>
<span class="sd">                [-0.4058, -0.5909, -0.4918, -0.2994,  0.5440]])</span>
<span class="sd">        &gt;&gt;&gt; pp.RxSO3([0, 0, 0, 1, 1])</span>
<span class="sd">        RxSO3Type LieTensor:</span>
<span class="sd">        tensor([0., 0., 0., 1., 1.])</span>
<span class="sd">    &#39;&#39;&#39;</span><span class="p">)</span>

<span class="n">rxso3</span> <span class="o">=</span> <span class="n">_LieTensor_wrapper_add_docstr</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">LieTensor</span><span class="p">,</span> <span class="n">ltype</span><span class="o">=</span><span class="n">rxso3_type</span><span class="p">),</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;Internally, rxso3 LieTensors are stored by concatenating the axis-angle</span>
<span class="sd">    representation of the rotation with the log scale:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{data}[*, :] = [\delta_x, \delta_y, \delta_z, \log s],</span>

<span class="sd">    where :math:`\begin{pmatrix} \delta_x &amp; \delta_y &amp; \delta_z \end{pmatrix}^T`</span>
<span class="sd">    is the axis-angle vector in :obj:`pypose.so3`, and</span>
<span class="sd">    :math:`s \in \mathbb{R}` is the scaling factor in :obj:`pypose.RxSO3`.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; pp.rxso3(torch.randn(2, 4))</span>
<span class="sd">        rxso3Type LieTensor:</span>
<span class="sd">        tensor([[ 0.3752, -0.1576,  1.2057,  0.6086],</span>
<span class="sd">                [ 0.8434,  0.2449,  0.0488, -0.1202]])</span>
<span class="sd">        &gt;&gt;&gt; pp.rxso3([0, 0, 0, 0, 1])</span>
<span class="sd">        RxSO3Type LieTensor:</span>
<span class="sd">        tensor([0., 0., 0., 0., 1.])</span>
<span class="sd">    &#39;&#39;&#39;</span><span class="p">)</span>

<span class="n">Sim3</span> <span class="o">=</span> <span class="n">_LieTensor_wrapper_add_docstr</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">LieTensor</span><span class="p">,</span> <span class="n">ltype</span><span class="o">=</span><span class="n">Sim3_type</span><span class="p">),</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;Internally, Sim3 LieTensors are stored by concatenating the translation</span>
<span class="sd">    vector with an RxSO3:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{data}[*, :] = [t_x, t_y, t_z, q_x, q_y, q_z, q_w, s],</span>

<span class="sd">    where :math:`\begin{pmatrix} t_x &amp; t_y &amp; t_z \end{pmatrix}^T \in \mathbb{R}^3`</span>
<span class="sd">    is the translation vector and</span>
<span class="sd">    :math:`\begin{pmatrix} q_x &amp; q_y &amp; q_z &amp; q_w \end{pmatrix}^T` and</span>
<span class="sd">    :math:`s \in \mathbb{R}` are the unit quaternion and the scaling factor</span>
<span class="sd">    as in :obj:`pp.RxSO3`, respectively.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; pp.Sim3(torch.randn(2, 8))</span>
<span class="sd">        Sim3Type LieTensor:</span>
<span class="sd">        tensor([[ 0.0175,  0.8657, -0.2274,  2.2380, -0.0297, -0.3799, -0.0664,  0.9995],</span>
<span class="sd">                [ 0.8744,  0.4114,  1.2041, -0.5687, -0.5630,  0.6025, -0.6137,  1.1185]])</span>
<span class="sd">        &gt;&gt;&gt; pp.Sim3([0, 0, 0, 0, 0, 0, 1, 1])</span>
<span class="sd">        Sim3Type LieTensor:</span>
<span class="sd">        tensor([0., 0., 0., 0., 0., 0., 1., 1.])</span>
<span class="sd">    &#39;&#39;&#39;</span><span class="p">)</span>

<span class="n">sim3</span> <span class="o">=</span> <span class="n">_LieTensor_wrapper_add_docstr</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">LieTensor</span><span class="p">,</span> <span class="n">ltype</span><span class="o">=</span><span class="n">sim3_type</span><span class="p">),</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;Internally, sim3 LieTensors are stored by concatenating the log translation</span>
<span class="sd">    vector with the corresponding rxso3:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{data}[*, :] = [\tau_x, \tau_y, \tau_z, \delta_x, \delta_y, \delta_z, \log s],</span>

<span class="sd">    where :math:`\begin{pmatrix} \tau_x &amp; \tau_y &amp; \tau_z \end{pmatrix}^T = \mathbf{W}^{-1}</span>
<span class="sd">    \begin{pmatrix} t_x &amp; t_y &amp; t_z \end{pmatrix}^T` is the product between the</span>
<span class="sd">    inverse of the :math:`\mathbf{W}`-matrix and the translation vector, and</span>
<span class="sd">    :math:`\begin{pmatrix} \delta_x &amp; \delta_y &amp; \delta_z &amp; \log s \end{pmatrix}^T`</span>
<span class="sd">    represents the rotation and scaling, as in :obj:`pypose.rxso3`.</span>
<span class="sd">    More details about :math:`\mathbf{W}`-matrix go to :meth:`pypose.Log` with</span>
<span class="sd">    :obj:`Sim3_type` input.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; pp.Sim3(torch.randn(2, 7))</span>
<span class="sd">        sim3Type LieTensor:</span>
<span class="sd">        sim3Type LieTensor:</span>
<span class="sd">        tensor([[ 0.1477, -1.3500, -2.1571,  0.8893, -0.7821, -0.9889, -0.7887],</span>
<span class="sd">                [ 0.2251,  0.3512,  0.0485,  0.0163, -1.7090, -0.0417, -0.3842]])</span>
<span class="sd">        &gt;&gt;&gt; pp.sim3([0, 0, 0, 0, 0, 0, 1])</span>
<span class="sd">        sim3Type LieTensor:</span>
<span class="sd">        tensor([0., 0., 0., 0., 0., 0., 1.])</span>
<span class="sd">    &#39;&#39;&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="randn_like"><a class="viewcode-back" href="../../../../generated/pypose.randn_like/#pypose.randn_like">[docs]</a><span class="k">def</span> <span class="nf">randn_like</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns a LieTensor with the same size as input that is filled with random</span>
<span class="sd">    LieTensor with the corresponding :obj:`input.ltype`.</span>

<span class="sd">    The corresponding random generator can be</span>

<span class="sd">    .. list-table:: List of available random LieTensor generator of input :obj:`ltype`.</span>
<span class="sd">        :widths: 25 25 30 30 30</span>
<span class="sd">        :header-rows: 1</span>

<span class="sd">        * - Name</span>
<span class="sd">          - ltype</span>
<span class="sd">          - randn function</span>
<span class="sd">          - Manifold</span>
<span class="sd">          - randn function</span>
<span class="sd">        * - Orthogonal Group</span>
<span class="sd">          - :obj:`SO3_type`</span>
<span class="sd">          - :meth:`randn_SO3`</span>
<span class="sd">          - :obj:`so3_type`</span>
<span class="sd">          - :meth:`randn_so3`</span>
<span class="sd">        * - Euclidean Group</span>
<span class="sd">          - :obj:`SE3_type`</span>
<span class="sd">          - :meth:`randn_SE3`</span>
<span class="sd">          - :obj:`se3_type`</span>
<span class="sd">          - :meth:`randn_se3`</span>
<span class="sd">        * - Similarity Group</span>
<span class="sd">          - :obj:`Sim3_type`</span>
<span class="sd">          - :meth:`randn_Sim3`</span>
<span class="sd">          - :obj:`sim3_type`</span>
<span class="sd">          - :meth:`randn_sim3`</span>
<span class="sd">        * - Scaling Orthogonal</span>
<span class="sd">          - :obj:`RxSO3_type`</span>
<span class="sd">          - :meth:`randn_RxSO3`</span>
<span class="sd">          - :obj:`rxso3_type`</span>
<span class="sd">          - :meth:`randn_rxso3`</span>

<span class="sd">    Args:</span>

<span class="sd">        input (LieTensor): the size of input will determine size of the output tensor.</span>

<span class="sd">        sigma (float or (float...), optional): standard deviation for generating random</span>
<span class="sd">            LieTensors. Default: ``1.0``.</span>

<span class="sd">        dtype (torch.dtype, optional): the desired data type of returned Tensor.</span>
<span class="sd">            Default: if ``None``, defaults to the dtype of input.</span>

<span class="sd">        layout (torch.layout, optional): the desired layout of returned tensor.</span>
<span class="sd">            Default: if ``None``, defaults to the layout of input.</span>

<span class="sd">        device (torch.device, optional): the desired device of returned tensor.</span>
<span class="sd">            Default: if ``None``, defaults to the device of input.</span>

<span class="sd">        requires_grad (bool, optional): If autograd should record operations on the returned</span>
<span class="sd">            tensor. Default: ``False``.</span>

<span class="sd">        memory_format (torch.memory_format, optional): the desired memory format of returned</span>
<span class="sd">            Tensor. Default: ``torch.preserve_format``.</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        The parameter sigma (:math:`\sigma`) can either be:</span>

<span class="sd">        - a single ``float`` -- in which all the elements in the LieType share the same</span>
<span class="sd">          sigma.</span>

<span class="sd">        - a ``tuple`` of a number of floats -- in which case, the specific sigma for</span>
<span class="sd">          each element can be assigned independently.</span>

<span class="sd">    Note:</span>
<span class="sd">        If we have:</span>

<span class="sd">        .. code::</span>

<span class="sd">            import pypose as pp</span>
<span class="sd">            x = pp.SO3([0, 0, 0, 1])</span>

<span class="sd">        Then the following two usages are equivalent:</span>

<span class="sd">        .. code::</span>

<span class="sd">            pp.randn_like(x)</span>
<span class="sd">            pp.randn_SO3(x.lshape, dtype=x.dtype, layout=x.layout, device=x.device)</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; x = pp.so3(torch.tensor([[0, 0, 0]]))</span>
<span class="sd">        &gt;&gt;&gt; pp.randn_like(x)</span>
<span class="sd">        so3Type LieTensor:</span>
<span class="sd">        tensor([[ 0.5162, -0.4600, -0.9085]])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="nb">input</span><span class="o">.</span><span class="n">ltype</span><span class="o">.</span><span class="n">randn_like</span><span class="p">(</span><span class="o">*</span><span class="nb">input</span><span class="o">.</span><span class="n">lshape</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="randn_so3"><a class="viewcode-back" href="../../../../generated/pypose.randn_so3/#pypose.randn_so3">[docs]</a><span class="k">def</span> <span class="nf">randn_so3</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns :obj:`so3_type` LieTensor filled with random numbers.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{aligned}</span>
<span class="sd">        \mathrm{data}[*, :] &amp;= [\delta_x, \delta_y, \delta_z] \\</span>
<span class="sd">                            &amp;= [\delta_x&#39;, \delta_y&#39;, \delta_z&#39;] \cdot \theta,</span>
<span class="sd">        \end{aligned}</span>

<span class="sd">    where :math:`[\delta_x&#39;, \delta_y&#39;, \delta_z&#39;]` is randomly generated from uniform</span>
<span class="sd">    distribution :math:`\mathcal{U}_{\mathrm{s}}` on a standard sphere and :math:`\theta`</span>
<span class="sd">    is generated from a normal distribution :math:`\mathcal{N}(0, \sigma)`, where sigma</span>
<span class="sd">    (:math:`\sigma`) is the standard deviation.</span>

<span class="sd">    The generated LieTensor satisfies that the corresponding rotation axis follows uniform</span>
<span class="sd">    distribution on the standard sphere and the rotation angle follows normal distribution.</span>

<span class="sd">    Args:</span>
<span class="sd">        lsize (int...): a sequence of integers defining the lshape of the output tensor.</span>
<span class="sd">            Can be a variable number of arguments or a collection like a list or tuple.</span>

<span class="sd">        sigma (float, optional): standard deviation for the angle of the generated rotation.</span>
<span class="sd">            Default: ``1.0``.</span>

<span class="sd">        requires_grad (bool, optional): If autograd should record operations on</span>
<span class="sd">            the returned tensor. Default: ``False``.</span>

<span class="sd">        generator (torch.Generator, optional): a pseudorandom number generator for sampling</span>

<span class="sd">        dtype (torch.dtype, optional): the desired data type of returned tensor.</span>
<span class="sd">            Default: ``None``. If ``None``, uses a global default</span>
<span class="sd">            (see :meth:`torch.set_default_tensor_type()`).</span>

<span class="sd">        layout (torch.layout, optional): the desired layout of returned Tensor.</span>
<span class="sd">            Default: ``torch.strided``.</span>

<span class="sd">        device (torch.device, optional): the desired device of returned tensor.</span>
<span class="sd">            Default: ``None``. If ``None``, uses the current device for the default tensor</span>
<span class="sd">            type (see :meth:`torch.set_default_tensor_type()`). Device will be the CPU</span>
<span class="sd">            for CPU tensor types and the current CUDA device for CUDA tensor types.</span>

<span class="sd">    Returns:</span>
<span class="sd">        LieTensor: a :obj:`so3_type` LieTensor</span>

<span class="sd">    Note:</span>
<span class="sd">        The uniform distributed points :math:`[\delta_x&#39;, \delta_y&#39;, \delta_z&#39;]` on a sphere</span>
<span class="sd">        are sampled using:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \delta_x&#39; = \frac{x_0}{d}, \delta_y&#39; = \frac{y_0}{d}, \delta_z&#39; = \frac{z_0}{d},</span>
<span class="sd">        </span>
<span class="sd">        where</span>

<span class="sd">        .. math::</span>
<span class="sd">            x_0, y_0, z_0 \sim \mathcal{N}(0, \sigma),</span>

<span class="sd">        .. math::</span>
<span class="sd">            d = \sqrt{(x^2_0+y^2_0+z^2_0)}.</span>

<span class="sd">        Note that the point :math:`[x_0, y_0, z_0]` follows 3-D Gaussian distribution, </span>
<span class="sd">        which is centrosymmetry with respect to :math:`(0, 0, 0)`. Therefore, we have</span>
<span class="sd">        :math:`\delta_x&#39;^2+\delta_y&#39;^2+\delta_z&#39;^2=1` and the normalized points follow</span>
<span class="sd">        uniform distribution on a standard sphere, i.e.,</span>
<span class="sd">        :math:`[\delta_x&#39;, \delta_y&#39;, \delta_z&#39;] \sim \mathcal{U}_{\mathrm{s}}`.</span>
<span class="sd">        The point :math:`[\delta_x&#39;, \delta_y&#39;, \delta_z&#39;]` can also represent an evenly</span>
<span class="sd">        sampled rotation axis.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; pp.randn_so3()</span>
<span class="sd">        so3Type LieTensor:</span>
<span class="sd">        LieTensor([ 0.4811, -0.1487, -0.5949])  # Shape (3)</span>
<span class="sd">        &gt;&gt;&gt; pp.randn_so3(1)</span>
<span class="sd">        so3Type LieTensor:</span>
<span class="sd">        LieTensor([[0.0235, 0.0334, 1.2601]])   # Shape (1, 3)</span>
<span class="sd">        &gt;&gt;&gt; pp.randn_so3(2, sigma=0.1, requires_grad=True, dtype=torch.float64)</span>
<span class="sd">        so3Type LieTensor:</span>
<span class="sd">        tensor([[-0.0344,  0.0177,  0.0252],</span>
<span class="sd">                [-0.0040,  0.0032,  0.0149]], dtype=torch.float64, requires_grad=True)</span>

<span class="sd">    .. figure:: /_static/img/lietensor/randn/randn_so3.svg</span>
<span class="sd">        :height: 1000px</span>
<span class="sd">        :width: 1000px</span>
<span class="sd">        :scale: 30 %</span>
<span class="sd">        :alt: map to buried treasure</span>
<span class="sd">        :align: center</span>

<span class="sd">        Visualization of :meth:`pypose.randn_so3()`. A total of 5000 random rotations</span>
<span class="sd">        are sampled using :meth:`pypose.randn_so3()` and applied to the basepoint</span>
<span class="sd">        [0, 0, 1] (shown in blue).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">so3_type</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="randn_SO3"><a class="viewcode-back" href="../../../../generated/pypose.randn_SO3/#pypose.randn_SO3">[docs]</a><span class="k">def</span> <span class="nf">randn_SO3</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns :obj:`SO3_type` LieTensor filled with the Exponential map of the random</span>
<span class="sd">    :obj:`so3_type` LieTensor.</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        \begin{aligned}</span>
<span class="sd">        \mathrm{data}[*, :] &amp;= \mathrm{Exp}([\delta_x, \delta_y, \delta_z]) \\</span>
<span class="sd">                            &amp;= \mathrm{Exp}([\delta_x&#39;, \delta_y&#39;, \delta_z&#39;] \cdot \theta),</span>
<span class="sd">        \end{aligned}</span>

<span class="sd">    where :math:`[\delta_x&#39;, \delta_y&#39;, \delta_z&#39;]` is generated from uniform distribution</span>
<span class="sd">    :math:`\mathcal{U}_{\mathrm{s}}` on a standard sphere, :math:`\mathrm{Exp}()` is the</span>
<span class="sd">    Exponential map, :math:`\theta` is generated from a normal distribution</span>
<span class="sd">    :math:`\mathcal{N}(0, \sigma)` where :math:`\sigma` (``sigma``) is the standard deviation.</span>

<span class="sd">    For detailed explanation, please see :meth:`pypose.randn_so3()` and :meth:`pypose.Exp()`.</span>

<span class="sd">    Args:</span>
<span class="sd">        lsize (int...): a sequence of integers defining the lshape of the output tensor.</span>
<span class="sd">            Can be a variable number of arguments or a collection like a list or tuple.</span>

<span class="sd">        sigma (float, optional): standard deviation for the angle of the generated rotation. </span>
<span class="sd">            Default: ``1.0``.</span>

<span class="sd">        requires_grad (bool, optional): If autograd should record operations on</span>
<span class="sd">            the returned tensor. Default: ``False``.</span>

<span class="sd">        generator (torch.Generator, optional): a pseudorandom number generator for sampling</span>

<span class="sd">        dtype (torch.dtype, optional): the desired data type of returned tensor.</span>
<span class="sd">            Default: ``None``. </span>
<span class="sd">            If ``None``, uses a global default (see :meth:`torch.set_default_tensor_type()`).</span>

<span class="sd">        layout (torch.layout, optional): the desired layout of returned Tensor.</span>
<span class="sd">            Default: ``torch.strided``.</span>

<span class="sd">        device (torch.device, optional): the desired device of returned tensor.</span>
<span class="sd">            Default: ``None``. If ``None``, uses the current device for the default tensor</span>
<span class="sd">            type (see :meth:`torch.set_default_tensor_type()`). Device will be the CPU</span>
<span class="sd">            for CPU tensor types and the current CUDA device for CUDA tensor types.</span>

<span class="sd">    Returns:</span>
<span class="sd">        LieTensor: a :obj:`SO3_type` LieTensor.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; pp.randn_SO3(sigma=0.1, requires_grad=True)</span>
<span class="sd">        SO3Type LieTensor:</span>
<span class="sd">        LieTensor([ 0.0082,  0.0077, -0.0018,  0.9999], requires_grad=True)</span>
<span class="sd">        &gt;&gt;&gt; pp.randn_SO3(2, sigma=0.1, requires_grad=True, dtype=torch.float64)</span>
<span class="sd">        SO3Type LieTensor:</span>
<span class="sd">        tensor([[ 2.6857e-03, -8.3274e-03, -6.0457e-04,  9.9996e-01],</span>
<span class="sd">                [ 3.8711e-02, -6.3148e-02, -1.9388e-02,  9.9706e-01]],</span>
<span class="sd">                dtype=torch.float64, requires_grad=True)</span>

<span class="sd">    .. figure:: /_static/img/lietensor/randn/randn_so3.svg</span>
<span class="sd">        :height: 1000px</span>
<span class="sd">        :width: 1000px</span>
<span class="sd">        :scale: 30 %</span>
<span class="sd">        :alt: map to buried treasure</span>
<span class="sd">        :align: center</span>

<span class="sd">        Visualization of :meth:`pypose.randn_SO3()`. A total of 5000 random rotations</span>
<span class="sd">        are sampled using :meth:`pypose.randn_SO3()` and applied to the basepoint</span>
<span class="sd">        [0, 0, 1] (shown in blue).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">SO3_type</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="randn_se3"><a class="viewcode-back" href="../../../../generated/pypose.randn_se3/#pypose.randn_se3">[docs]</a><span class="k">def</span> <span class="nf">randn_se3</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns :obj:`se3_type` LieTensor filled with random numbers. </span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{data}[*, :] = [\tau_x, \tau_y, \tau_z, \delta_x, \delta_y, \delta_z],</span>
<span class="sd">    </span>
<span class="sd">    where translation :math:`[\tau_x, \tau_y, \tau_z]` is generated from a normal distribution </span>
<span class="sd">    :math:`\mathcal{N}(0, \sigma_t)`, rotation :math:`[\delta_x, \delta_y, \delta_z]` is</span>
<span class="sd">    generated using :meth:`pypose.randn_so3()` with standard deviation :math:`\sigma_r`.</span>
<span class="sd">    Note that standard deviations :math:`\sigma_t` and :math:`\sigma_r` are</span>
<span class="sd">    specified by ``sigma`` (:math:`\sigma`), where :math:`\sigma = (\sigma_t, \sigma_r)`.</span>

<span class="sd">    Args:</span>
<span class="sd">        lsize (int...): a sequence of integers defining the lshape of the output tensor.</span>
<span class="sd">            Can be a variable number of arguments or a collection like a list or tuple.</span>

<span class="sd">        sigma (float or (float...), optional): standard deviation </span>
<span class="sd">            (:math:`\sigma_t` and :math:`\sigma_r`) </span>
<span class="sd">            for the two normal distribution. Default: ``1.0``.</span>

<span class="sd">        requires_grad (bool, optional): If autograd should record operations on</span>
<span class="sd">            the returned tensor. Default: ``False``.</span>

<span class="sd">        generator (torch.Generator, optional): a pseudorandom number generator for sampling</span>

<span class="sd">        dtype (torch.dtype, optional): the desired data type of returned tensor.</span>
<span class="sd">            Default: ``None``. If ``None``, uses a global default </span>
<span class="sd">            (see :meth:`torch.set_default_tensor_type()`).</span>

<span class="sd">        layout (torch.layout, optional): the desired layout of returned Tensor.</span>
<span class="sd">            Default: ``torch.strided``.</span>

<span class="sd">        device (torch.device, optional): the desired device of returned tensor.</span>
<span class="sd">            Default: ``None``. If ``None``, uses the current device for the default tensor</span>
<span class="sd">            type (see :meth:`torch.set_default_tensor_type()`). Device will be the CPU</span>
<span class="sd">            for CPU tensor types and the current CUDA device for CUDA tensor types.</span>

<span class="sd">    Returns:</span>
<span class="sd">        LieTensor: a :obj:`se3_type` LieTensor.</span>

<span class="sd">    Note:</span>
<span class="sd">        The parameter :math:`\sigma` can either be:</span>

<span class="sd">        - a single ``float`` -- in which all the elements in the :obj:`se3_type` </span>
<span class="sd">          share the same sigma, i.e., </span>
<span class="sd">          :math:`\sigma_{\rm{t}}` = :math:`\sigma_{\rm{r}}` = :math:`\sigma`.</span>
<span class="sd">        - a ``tuple`` of two floats -- in which case, the specific sigmas are </span>
<span class="sd">          assigned independently, i.e., </span>
<span class="sd">          :math:`\sigma` = (:math:`\sigma_{\rm{t}}`, :math:`\sigma_{\rm{r}}`).</span>
<span class="sd">        - a ``tuple`` of four floats -- in which case, the specific sigmas for </span>
<span class="sd">          each translation data are assigned independently, i.e., </span>
<span class="sd">          :math:`\sigma` = (:math:`\sigma_{\rm{tx}}`, :math:`\sigma_{\rm{ty}}`, </span>
<span class="sd">          :math:`\sigma_{\rm{tz}}`, :math:`\sigma_{\rm{r}}`).</span>

<span class="sd">    Example:</span>

<span class="sd">        For :math:`\sigma = (\sigma_t, \sigma_r)`</span>

<span class="sd">        &gt;&gt;&gt; pp.randn_se3(2, sigma=(1.0, 0.5))</span>
<span class="sd">        se3Type LieTensor:</span>
<span class="sd">        tensor([[-0.4226,  0.4028, -1.3824,  0.4433, -0.2029, -0.1193],</span>
<span class="sd">                [-0.8423, -1.0435,  0.8311, -0.4733,  0.0175,  0.1400]])</span>

<span class="sd">        For :math:`\sigma = (\sigma_{tx}, \sigma_{ty}, \sigma_{tz}, \sigma_{r})`</span>

<span class="sd">        &gt;&gt;&gt; pp.randn_se3(2, sigma=(1.0, 2.0, 3.0, 0.5))</span>
<span class="sd">        se3Type LieTensor:</span>
<span class="sd">        tensor([[ 1.1209,  1.4211, -0.7237, -0.1168,  0.0128,  0.1479],</span>
<span class="sd">                [ 0.1765,  0.3891,  3.4799, -0.0411, -0.2616, -0.1028]])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">se3_type</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="randn_SE3"><a class="viewcode-back" href="../../../../generated/pypose.randn_SE3/#pypose.randn_SE3">[docs]</a><span class="k">def</span> <span class="nf">randn_SE3</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns :obj:`SE3_type` LieTensor filled with the Exponential map of the random</span>
<span class="sd">    :obj:`se3_type` LieTensor generated using :meth:`pypose.randn_se3()`.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{data}[*, :] = \mathrm{Exp}([\tau_x, \tau_y, \tau_z, \delta_x, \delta_y, \delta_z]),</span>

<span class="sd">    where :math:`[\tau_x, \tau_y, \tau_z]` is generated from a normal distribution </span>
<span class="sd">    :math:`\mathcal{N}(0, \sigma_t)`, :math:`[\delta_x, \delta_y, \delta_z]` is</span>
<span class="sd">    generated using :meth:`pypose.randn_so3()` with with standard deviation</span>
<span class="sd">    :math:`\sigma_r`, and :math:`\mathrm{Exp}()` is the Exponential map. Note that standard</span>
<span class="sd">    deviations :math:`\sigma_t` and :math:`\sigma_r` are specified by ``sigma`` (:math:`\sigma`),</span>
<span class="sd">    where :math:`\sigma = (\sigma_t, \sigma_r)`.</span>

<span class="sd">    For detailed explanation, please see :meth:`pypose.randn_se3()` and :meth:`pypose.Exp()`.</span>

<span class="sd">    Args:</span>
<span class="sd">        lsize (int...): a sequence of integers defining the lshape of the output tensor.</span>
<span class="sd">            Can be a variable number of arguments or a collection like a list or tuple.</span>

<span class="sd">        sigma (float or (float...), optional): standard deviation </span>
<span class="sd">            (:math:`\sigma_t` and :math:`\sigma_r`) for the two normal distribution.</span>
<span class="sd">            Default: ``1.0``.</span>

<span class="sd">        requires_grad (bool, optional): If autograd should record operations on</span>
<span class="sd">            the returned tensor. Default: ``False``.</span>

<span class="sd">        generator (torch.Generator, optional): a pseudorandom number generator for sampling</span>

<span class="sd">        dtype (torch.dtype, optional): the desired data type of returned tensor.</span>
<span class="sd">            Default: ``None``. If None, uses a global default </span>
<span class="sd">            (see :meth:`torch.set_default_tensor_type()`).</span>

<span class="sd">        layout (torch.layout, optional): the desired layout of returned Tensor.</span>
<span class="sd">            Default: ``torch.strided``.</span>

<span class="sd">        device (torch.device, optional): the desired device of returned tensor.</span>
<span class="sd">            Default: ``None``. If ``None``, uses the current device for the default tensor</span>
<span class="sd">            type (see :meth:`torch.set_default_tensor_type()`). Device will be the CPU</span>
<span class="sd">            for CPU tensor types and the current CUDA device for CUDA tensor types.</span>

<span class="sd">    Returns:</span>
<span class="sd">        LieTensor: a :obj:`SE3_type` LieTensor</span>

<span class="sd">    Note:</span>
<span class="sd">        The parameter :math:`\sigma` can either be:</span>

<span class="sd">        - a single ``float`` -- in which all the elements in the :obj:`SE3_type` </span>
<span class="sd">          share the same sigma, i.e., </span>
<span class="sd">          :math:`\sigma_{\rm{t}}` = :math:`\sigma_{\rm{r}}` = :math:`\sigma`.</span>
<span class="sd">        - a ``tuple`` of two floats -- in which case, the specific sigmas are </span>
<span class="sd">          assigned independently, i.e.,</span>
<span class="sd">          :math:`\sigma` = (:math:`\sigma_{\rm{t}}`, :math:`\sigma_{\rm{r}}`).</span>
<span class="sd">        - a ``tuple`` of four floats -- in which case, the specific sigmas for</span>
<span class="sd">          each translation data are assigned independently, i.e., </span>
<span class="sd">          :math:`\sigma` = (:math:`\sigma_{\rm{tx}}`, :math:`\sigma_{\rm{ty}}`, </span>
<span class="sd">          :math:`\sigma_{\rm{tz}}`, :math:`\sigma_{\rm{r}}`).</span>

<span class="sd">    Example:</span>

<span class="sd">        For :math:`\sigma = (\sigma_t, \sigma_r)`</span>

<span class="sd">        &gt;&gt;&gt; pp.randn_SE3(2, sigma=(1.0, 2.0))</span>
<span class="sd">        SE3Type LieTensor:</span>
<span class="sd">        tensor([[ 0.2947, -1.6990, -0.5535,  0.4439,  0.2777,  0.0518,  0.8504],</span>
<span class="sd">                [ 0.6825,  0.2963,  0.3410,  0.3375, -0.2355,  0.7389, -0.5335]])</span>

<span class="sd">        For :math:`\sigma = (\sigma_{tx}, \sigma_{ty}, \sigma_{tz}, \sigma_{r})`</span>

<span class="sd">        &gt;&gt;&gt; pp.randn_SE3(2, sigma=(1.0, 1.5, 2.0, 2.0))</span>
<span class="sd">        SE3Type LieTensor:</span>
<span class="sd">        tensor([[-1.5689, -0.6772,  0.3580, -0.2509,  0.8257, -0.4950,  0.1018],</span>
<span class="sd">                [ 0.2613, -2.7613,  0.2151, -0.8802,  0.2619,  0.3044,  0.2531]])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">SE3_type</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="randn_sim3"><a class="viewcode-back" href="../../../../generated/pypose.randn_sim3/#pypose.randn_sim3">[docs]</a><span class="k">def</span> <span class="nf">randn_sim3</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns :obj:`sim3_type` LieTensor filled with random numbers. </span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{data}[*, :] = [\tau_x, \tau_y, \tau_z, \delta_x, \delta_y, \delta_z, \log s],</span>

<span class="sd">    where translation :math:`[\tau_x, \tau_y, \tau_z]` is generated from a normal distribution </span>
<span class="sd">    :math:`\mathcal{N}(0, \sigma_t)`, rotation :math:`[\delta_x, \delta_y, \delta_z]` is</span>
<span class="sd">    generated using :meth:`pypose.randn_so3()` with standard deviation :math:`\sigma_r`,</span>
<span class="sd">    scale :math:`\log s` is generated from a normal distribution :math:`\mathcal{N}(0, \sigma_s)`.</span>
<span class="sd">    Note that standard deviations :math:`\sigma_t`, :math:`\sigma_r`, and :math:`\sigma_s` are</span>
<span class="sd">    specified by ``sigma`` (:math:`\sigma`), where :math:`\sigma=(\sigma_t,\sigma_r,\sigma_s)`.</span>

<span class="sd">    Args:</span>
<span class="sd">        lsize (int...): a sequence of integers defining the lshape of the output tensor.</span>
<span class="sd">            Can be a variable number of arguments or a collection like a list or tuple.</span>

<span class="sd">        sigma (float or (float...), optional): standard deviation (:math:`\sigma_t`, </span>
<span class="sd">            :math:`\sigma_r`, and :math:`\sigma_s`) for the three normal distribution.</span>
<span class="sd">            Default: ``1.0``.</span>

<span class="sd">        requires_grad (bool, optional): If autograd should record operations on</span>
<span class="sd">            the returned tensor. Default: ``False``.</span>

<span class="sd">        generator (torch.Generator, optional): a pseudorandom number generator for sampling.</span>

<span class="sd">        dtype (torch.dtype, optional): the desired data type of returned tensor.</span>
<span class="sd">            Default: ``None``. If ``None``, uses a global default </span>
<span class="sd">            (see :meth:`torch.set_default_tensor_type()`).</span>

<span class="sd">        layout (torch.layout, optional): the desired layout of returned Tensor.</span>
<span class="sd">            Default: ``torch.strided``.</span>

<span class="sd">        device (torch.device, optional): the desired device of returned tensor.</span>
<span class="sd">            Default: ``None``. If ``None``, uses the current device for the default tensor</span>
<span class="sd">            type (see :meth:`torch.set_default_tensor_type()`). Device will be the CPU</span>
<span class="sd">            for CPU tensor types and the current CUDA device for CUDA tensor types.</span>

<span class="sd">    Returns:</span>
<span class="sd">        LieTensor: a ``sim3_type`` LieTensor.</span>

<span class="sd">    Note:</span>
<span class="sd">        The parameter :math:`\sigma` can either be:</span>

<span class="sd">        - a single ``float`` -- in which all the elements in the :obj:`sim3_type` </span>
<span class="sd">          share the same sigma, i.e., </span>
<span class="sd">          :math:`\sigma_{\rm{t}}` = :math:`\sigma_{\rm{r}}` = :math:`\sigma_{\rm{s}}` </span>
<span class="sd">          = :math:`\sigma`.</span>
<span class="sd">        - a ``tuple`` of three floats -- in which case, the specific sigmas for </span>
<span class="sd">          the three parts are assigned independently, i.e., </span>
<span class="sd">          :math:`\sigma` = (:math:`\sigma_{\rm{t}}`, :math:`\sigma_{\rm{r}}`, </span>
<span class="sd">          :math:`\sigma_{\rm{s}}`).</span>
<span class="sd">        - a ``tuple`` of five floats -- in which case, the specific sigmas for </span>
<span class="sd">          each translation data are also assigned independently, i.e.,</span>
<span class="sd">          :math:`\sigma` = (:math:`\sigma_{\rm{tx}}`, :math:`\sigma_{\rm{ty}}`, </span>
<span class="sd">          :math:`\sigma_{\rm{tz}}`, :math:`\sigma_{\rm{r}}`, :math:`\sigma_{\rm{s}}`).</span>

<span class="sd">    Example:</span>
<span class="sd">        For :math:`\sigma = (\sigma_{\rm{t}}, \sigma_{\rm{r}}, \sigma_{\rm{s}})`</span>

<span class="sd">        &gt;&gt;&gt; pp.randn_sim3(sigma=(1.0, 1.0, 2.0))</span>
<span class="sd">        sim3Type LieTensor:</span>
<span class="sd">        LieTensor([ 1.1994, -1.6163, -0.7566, -0.1805,  0.2199, -0.7044, -3.9935])</span>

<span class="sd">        For :math:`\sigma = (\sigma_{\rm{tx}}, \sigma_{\rm{ty}}, \sigma_{\rm{tz}},</span>
<span class="sd">        \sigma_{\rm{r}}, \sigma_{\rm{s})}`</span>

<span class="sd">        &gt;&gt;&gt; pp.randn_sim3(2, sigma=(1.0, 1.0, 2.0, 1.0, 2.0))</span>
<span class="sd">        sim3Type LieTensor:</span>
<span class="sd">        tensor([[ 0.3995, -1.9705,  2.6748,  0.5061, -1.4121,  1.1144,  0.5393],</span>
<span class="sd">                [ 0.7968,  0.5076,  1.0034,  0.8263,  1.3350, -0.0851,  2.2611]])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">sim3_type</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="randn_Sim3"><a class="viewcode-back" href="../../../../generated/pypose.randn_Sim3/#pypose.randn_Sim3">[docs]</a><span class="k">def</span> <span class="nf">randn_Sim3</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns :obj:`Sim3_type` LieTensor filled with the Exponential map of the random</span>
<span class="sd">    :obj:`sim3_type` LieTensor generated using :meth:`randn_sim3()`.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{data}[*, :] = \mathrm{Exp}([\tau_x, \tau_y, \tau_z, \delta_x,</span>
<span class="sd">        \delta_y, \delta_z, \log s]),</span>

<span class="sd">    where translation :math:`[\tau_x, \tau_y, \tau_z]` is generated from a normal distribution </span>
<span class="sd">    :math:`\mathcal{N}(0, \sigma_t)`, rotation :math:`[\delta_x, \delta_y, \delta_z]` is</span>
<span class="sd">    generated using :meth:`pypose.randn_so3()` with with standard deviation</span>
<span class="sd">    :math:`\sigma_r`, scale :math:`\log s` is generated from a normal distribution</span>
<span class="sd">    :math:`\mathcal{N}(0, \sigma_s)`, and :math:`\mathrm{Exp}()` is the Exponential</span>
<span class="sd">    map. Note that standard deviations :math:`\sigma_t`, :math:`\sigma_r`, and</span>
<span class="sd">    :math:`\sigma_s` are specified by ``sigma`` (:math:`\sigma`), where</span>
<span class="sd">    :math:`\sigma = (\sigma_t, \sigma_r, \sigma_s)`.</span>

<span class="sd">    For detailed explanation, please see :meth:`pypose.randn_sim3()` and :meth:`pypose.Exp()`.</span>

<span class="sd">    Args:</span>
<span class="sd">        lsize (int...): a sequence of integers defining the lshape of the output tensor.</span>
<span class="sd">            Can be a variable number of arguments or a collection like a list or tuple.</span>

<span class="sd">        sigma (float or (float...), optional): standard deviation</span>
<span class="sd">            (:math:`\sigma_t`, :math:`\sigma_r`, and :math:`\sigma_s`) </span>
<span class="sd">            for the three normal distribution. Default: ``1.0``.</span>

<span class="sd">        requires_grad (bool, optional): If autograd should record operations on</span>
<span class="sd">            the returned tensor. Default: ``False``.</span>

<span class="sd">        generator (torch.Generator, optional): a pseudorandom number generator for sampling</span>

<span class="sd">        dtype (torch.dtype, optional): the desired data type of returned tensor.</span>
<span class="sd">            Default: ``None``. If ``None``, uses a global default </span>
<span class="sd">            (see :meth:`torch.set_default_tensor_type()`).</span>

<span class="sd">        layout (torch.layout, optional): the desired layout of returned Tensor.</span>
<span class="sd">            Default: ``torch.strided``.</span>

<span class="sd">        device (torch.device, optional): the desired device of returned tensor.</span>
<span class="sd">            Default: ``None``. If ``None``, uses the current device for the default tensor</span>
<span class="sd">            type (see :meth:`torch.set_default_tensor_type()`). Device will be the CPU</span>
<span class="sd">            for CPU tensor types and the current CUDA device for CUDA tensor types.</span>

<span class="sd">    Returns:</span>
<span class="sd">        LieTensor: a :obj:`Sim_type` LieTensor</span>

<span class="sd">    Note:</span>
<span class="sd">        The parameter :math:`\sigma` can either be:</span>

<span class="sd">        - a single ``float`` -- in which all the elements in the :obj:`Sim3_type` </span>
<span class="sd">          share the same sigma, i.e., </span>
<span class="sd">          :math:`\sigma_{\rm{t}}` = :math:`\sigma_{\rm{r}}` </span>
<span class="sd">          = :math:`\sigma_{\rm{s}}` = :math:`\sigma`.</span>
<span class="sd">        - a ``tuple`` of three floats -- in which case, the specific sigmas </span>
<span class="sd">          for the three parts are assigned independently, i.e., </span>
<span class="sd">          :math:`\sigma` = (:math:`\sigma_{\rm{t}}`, :math:`\sigma_{\rm{r}}`, </span>
<span class="sd">          :math:`\sigma_{\rm{s}}`).</span>
<span class="sd">        - a ``tuple`` of five floats -- in which case, the specific sigmas </span>
<span class="sd">          for each translation data are also assigned independently, i.e.,</span>
<span class="sd">          :math:`\sigma` = (:math:`\sigma_{\rm{tx}}`, :math:`\sigma_{\rm{ty}}`, </span>
<span class="sd">          :math:`\sigma_{\rm{tz}}`, :math:`\sigma_{\rm{r}}`, :math:`\sigma_{\rm{s}}`).</span>

<span class="sd">    Example:</span>
<span class="sd">        For :math:`\sigma = (\sigma_{\rm{t}}, \sigma_{\rm{r}}, \sigma_{\rm{s}})`</span>

<span class="sd">        &gt;&gt;&gt; pp.randn_Sim3(sigma=(1.0, 1.0, 2.0))</span>
<span class="sd">        Sim3Type LieTensor:</span>
<span class="sd">        LieTensor([-0.7667, -0.0981,  0.8168,  0.0931,  0.0917,  0.0939,  0.9870, 0.2391])</span>

<span class="sd">        For :math:`\sigma = (\sigma_{\rm{tx}}, \sigma_{\rm{ty}}, \sigma_{\rm{tz}},</span>
<span class="sd">        \sigma_{\rm{r}}, \sigma_{\rm{s})}`</span>

<span class="sd">        &gt;&gt;&gt; pp.randn_Sim3(2, sigma=(1.0, 1.0, 2.0, 1.0, 2.0))</span>
<span class="sd">        Sim3Type LieTensor:</span>
<span class="sd">        tensor([[-0.0117,  0.0708,  1.6853,  0.1089,  0.4186, -0.0877,  0.8973,  0.3969],</span>
<span class="sd">                [ 0.2106, -0.0694, -0.0574, -0.2902, -0.4806, -0.0815,  0.8235,  0.0134]])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">Sim3_type</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="randn_rxso3"><a class="viewcode-back" href="../../../../generated/pypose.randn_rxso3/#pypose.randn_rxso3">[docs]</a><span class="k">def</span> <span class="nf">randn_rxso3</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns :obj:`rxso3_type` LieTensor filled with random numbers. </span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{data}[*, :] = [\delta_x, \delta_y, \delta_z, \log s],</span>

<span class="sd">    where rotation :math:`[\delta_x, \delta_y, \delta_z]` is</span>
<span class="sd">    generated using :meth:`pypose.randn_so3()` with standard deviation :math:`\sigma_r`,</span>
<span class="sd">    scale :math:`\log s` is generated from a normal distribution :math:`\mathcal{N}(0, \sigma_s)`.</span>
<span class="sd">    Note that standard deviations :math:`\sigma_r` and :math:`\sigma_s` are</span>
<span class="sd">    specified by ``sigma`` (:math:`\sigma`), where :math:`\sigma = (\sigma_r, \sigma_s)`.</span>

<span class="sd">    Args:</span>
<span class="sd">        lsize (int...): a sequence of integers defining the lshape of the output tensor.</span>
<span class="sd">            Can be a variable number of arguments or a collection like a list or tuple.</span>

<span class="sd">        sigma (float or (float...), optional): standard deviation (:math:`\sigma_r`, </span>
<span class="sd">            and :math:`\sigma_s`) for the two normal distribution. Default: ``1.0``.</span>

<span class="sd">        requires_grad (bool, optional): If autograd should record operations on</span>
<span class="sd">            the returned tensor. Default: ``False``.</span>

<span class="sd">        generator (torch.Generator, optional): a pseudorandom number generator for sampling</span>

<span class="sd">        dtype (torch.dtype, optional): the desired data type of returned tensor.</span>
<span class="sd">            Default: ``None``. If ``None``, uses a global default </span>
<span class="sd">            (see :meth:`torch.set_default_tensor_type()`).</span>

<span class="sd">        layout (torch.layout, optional): the desired layout of returned Tensor.</span>
<span class="sd">            Default: ``torch.strided``.</span>

<span class="sd">        device (torch.device, optional): the desired device of returned tensor.</span>
<span class="sd">            Default: ``None``. If ``None``, uses the current device for the default tensor</span>
<span class="sd">            type (see :meth:`torch.set_default_tensor_type()`). Device will be the CPU</span>
<span class="sd">            for CPU tensor types and the current CUDA device for CUDA tensor types.</span>

<span class="sd">    Returns:</span>
<span class="sd">        LieTensor: a :obj:`rxso3_type` LieTensor</span>

<span class="sd">    Note:</span>
<span class="sd">        The parameter :math:`\sigma` can either be:</span>

<span class="sd">        - a single ``float`` -- in which all the elements in the :obj:`rxso3_type` share </span>
<span class="sd">          the same sigma, i.e., :math:`\sigma_{\rm{r}}` = :math:`\sigma_{\rm{s}}` </span>
<span class="sd">          = :math:`\sigma`.</span>
<span class="sd">        - a ``tuple`` of two floats -- in which case, the specific sigmas for the two parts </span>
<span class="sd">          are assigned independently, i.e., :math:`\sigma` = (:math:`\sigma_{\rm{r}}`, </span>
<span class="sd">          :math:`\sigma_{\rm{s}}`).</span>

<span class="sd">    Example:</span>

<span class="sd">        For :math:`\sigma = (\sigma_r, \sigma_s)`</span>

<span class="sd">        &gt;&gt;&gt; pp.randn_rxso3(2, sigma=(1.0, 2.0))</span>
<span class="sd">        rxso3Type LieTensor:</span>
<span class="sd">        tensor([[-0.5033, -0.4102, -0.6213, -3.5049],</span>
<span class="sd">                [-0.3185,  0.1053, -0.0816, -1.1907]])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">rxso3_type</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="randn_RxSO3"><a class="viewcode-back" href="../../../../generated/pypose.randn_RxSO3/#pypose.randn_RxSO3">[docs]</a><span class="k">def</span> <span class="nf">randn_RxSO3</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns :obj:`RxSO3_type` LieTensor filled with the Exponential map of the random</span>
<span class="sd">    :obj:`rxso3_type` LieTensor. The :obj:`rxso3_type` LieTensor is generated using </span>
<span class="sd">    :meth:`randn_rxso3()`.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{data}[*, :] = \mathrm{Exp}([\delta_x, \delta_y, \delta_z, \log s]),</span>

<span class="sd">    where rotation :math:`[\delta_x, \delta_y, \delta_z]` is generated using</span>
<span class="sd">    :meth:`pypose.randn_so3()` with standard deviation :math:`\sigma_r`, scale :math:`\log s`</span>
<span class="sd">    is generated from a normal distribution :math:`\mathcal{N}(0, \sigma_s)`, and</span>
<span class="sd">    :math:`\mathrm{Exp}()` is the Exponential map. Note that standard deviations</span>
<span class="sd">    :math:`\sigma_r` and :math:`\sigma_s` are specified by ``sigma`` (:math:`\sigma`), where</span>
<span class="sd">    :math:`\sigma = (\sigma_r, \sigma_s)`.</span>

<span class="sd">    Args:</span>
<span class="sd">        lsize (int...): a sequence of integers defining the lshape of the output tensor.</span>
<span class="sd">            Can be a variable number of arguments or a collection like a list or tuple.</span>

<span class="sd">        sigma (float or (float...), optional): standard deviation (:math:`\sigma_r`, </span>
<span class="sd">            and :math:`\sigma_s`) for the two normal distribution. Default: ``1.0``.</span>

<span class="sd">        requires_grad (bool, optional): If autograd should record operations on</span>
<span class="sd">            the returned tensor. Default: ``False``.</span>

<span class="sd">        generator (torch.Generator, optional): a pseudorandom number generator for sampling</span>

<span class="sd">        dtype (torch.dtype, optional): the desired data type of returned tensor.</span>
<span class="sd">            Default: ``None``. If ``None``, uses a global default </span>
<span class="sd">            (see :meth:`torch.set_default_tensor_type()`).</span>

<span class="sd">        layout (torch.layout, optional): the desired layout of returned Tensor.</span>
<span class="sd">            Default: ``torch.strided``.</span>

<span class="sd">        device (torch.device, optional): the desired device of returned tensor.</span>
<span class="sd">            Default: &quot;None&quot;. If None, uses the current device for the default tensor</span>
<span class="sd">            type (see :meth:`torch.set_default_tensor_type()`). Device will be the CPU</span>
<span class="sd">            for CPU tensor types and the current CUDA device for CUDA tensor types.</span>

<span class="sd">    Returns:</span>
<span class="sd">        LieTensor: a :obj:`RxSO3_type` LieTensor</span>

<span class="sd">    Note:</span>
<span class="sd">        The parameter :math:`\sigma` can either be:</span>

<span class="sd">        - a single ``float`` -- in which all the elements in the :obj:`RxSO3_type` share </span>
<span class="sd">          the same sigma, i.e., :math:`\sigma_{\rm{r}}` = :math:`\sigma_{\rm{s}}` = </span>
<span class="sd">          :math:`\sigma`.</span>
<span class="sd">        - a ``tuple`` of two floats -- in which case, the specific sigmas for the two parts </span>
<span class="sd">          are assigned independently, i.e., :math:`\sigma` = (:math:`\sigma_{\rm{r}}`, </span>
<span class="sd">          :math:`\sigma_{\rm{s}}`).</span>

<span class="sd">    Example:</span>

<span class="sd">        For :math:`\sigma = (\sigma_r, \sigma_s)`</span>

<span class="sd">        &gt;&gt;&gt; pp.randn_RxSO3(2, sigma=(1.0, 2.0))</span>
<span class="sd">        RxSO3Type LieTensor:</span>
<span class="sd">        tensor([[-0.1929, -0.0141,  0.2859,  0.9385,  4.5562],</span>
<span class="sd">                [-0.2871,  0.0134, -0.2903,  0.9128,  3.1044]])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">RxSO3_type</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="identity_like"><a class="viewcode-back" href="../../../../generated/pypose.identity_like/#pypose.identity_like">[docs]</a><span class="k">def</span> <span class="nf">identity_like</span><span class="p">(</span><span class="n">liegroup</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">     Returns identity LieTensor with the same :obj:`lsize` and :obj:`ltype` as the given LieTensor.</span>

<span class="sd">    Args:</span>
<span class="sd">        liegroup (LieTensor): the size of liegroup will determine the size of the output tensor. </span>

<span class="sd">    Args:</span>
<span class="sd">        requires_grad (bool, optional): If autograd should record operations on</span>
<span class="sd">            the returned tensor. Default: False.</span>

<span class="sd">        generator (torch.Generator, optional): a pseudorandom number generator for sampling</span>

<span class="sd">        dtype (torch.dtype, optional): the desired data type of returned tensor.</span>
<span class="sd">            Default: if None, uses a global default (see :meth:`torch.set_default_tensor_type()`).</span>

<span class="sd">        layout (torch.layout, optional): the desired layout of returned Tensor.</span>
<span class="sd">            Default: torch.strided.</span>

<span class="sd">        device (torch.device, optional): the desired device of returned tensor.</span>
<span class="sd">            Default: if None, uses the current device for the default tensor</span>
<span class="sd">            type (see :meth:`torch.set_default_tensor_type()`). device will be the CPU</span>
<span class="sd">            for CPU tensor types and the current CUDA device for CUDA tensor types.</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; x = pp.randn_SO3(3, device=&quot;cuda:0&quot;, dtype=torch.double, requires_grad=True)</span>
<span class="sd">        &gt;&gt;&gt; pp.identity_like(x, device=&quot;cpu&quot;)</span>
<span class="sd">        SO3Type LieTensor:</span>
<span class="sd">        tensor([[0., 0., 0., 1.],</span>
<span class="sd">                [0., 0., 0., 1.],</span>
<span class="sd">                [0., 0., 0., 1.]])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">liegroup</span><span class="o">.</span><span class="n">ltype</span><span class="o">.</span><span class="n">identity_like</span><span class="p">(</span><span class="o">*</span><span class="n">liegroup</span><span class="o">.</span><span class="n">lshape</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="identity_SO3"><a class="viewcode-back" href="../../../../generated/pypose.identity_SO3/#pypose.identity_SO3">[docs]</a><span class="k">def</span> <span class="nf">identity_SO3</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns identity :obj:`SO3_type` LieTensor with the given :obj:`lsize`.</span>

<span class="sd">    See :obj:`SO3()` for implementation details.</span>

<span class="sd">    Args:</span>
<span class="sd">        lsize (int..., optional): a sequence of integers defining the :obj:`LieTensor.lshape` of</span>
<span class="sd">            the output LieTensor. Can be a variable number of arguments or a collection like a</span>
<span class="sd">            list or tuple. If not given, a single :obj:`SO3_type` item will be returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        requires_grad (bool, optional): If autograd should record operations on</span>
<span class="sd">            the returned tensor. Default: False.</span>

<span class="sd">        generator (torch.Generator, optional): a pseudorandom number generator for sampling</span>

<span class="sd">        dtype (torch.dtype, optional): the desired data type of returned tensor.</span>
<span class="sd">            Default: if None, uses a global default (see :meth:`torch.set_default_tensor_type()`).</span>

<span class="sd">        layout (torch.layout, optional): the desired layout of returned Tensor.</span>
<span class="sd">            Default: torch.strided.</span>

<span class="sd">        device (torch.device, optional): the desired device of returned tensor.</span>
<span class="sd">            Default: if None, uses the current device for the default tensor</span>
<span class="sd">            type (see :meth:`torch.set_default_tensor_type()`). device will be the CPU</span>
<span class="sd">            for CPU tensor types and the current CUDA device for CUDA tensor types.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        LieTensor: a :obj:`SO3_type` LieTensor</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; pp.identity_SO3()</span>
<span class="sd">        SO3Type LieTensor:</span>
<span class="sd">        tensor([0., 0., 0., 1.])</span>

<span class="sd">        &gt;&gt;&gt; pp.identity_SO3(2)</span>
<span class="sd">        SO3Type LieTensor:</span>
<span class="sd">        tensor([[0., 0., 0., 1.],</span>
<span class="sd">                [0., 0., 0., 1.]])</span>

<span class="sd">        &gt;&gt;&gt; pp.identity_SO3(2, 1)</span>
<span class="sd">        SO3Type LieTensor:</span>
<span class="sd">        tensor([[[0., 0., 0., 1.]],</span>
<span class="sd">                [[0., 0., 0., 1.]]])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">SO3_type</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="identity_so3"><a class="viewcode-back" href="../../../../generated/pypose.identity_so3/#pypose.identity_so3">[docs]</a><span class="k">def</span> <span class="nf">identity_so3</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns identity :obj:`so3_type` LieTensor with the given :obj:`lsize`.</span>
<span class="sd">    </span>
<span class="sd">    See :obj:`so3()` for implementation details.</span>

<span class="sd">    Args:</span>
<span class="sd">        lsize (int..., optional): a sequence of integers defining the :obj:`LieTensor.lshape` of</span>
<span class="sd">            the output LieTensor. Can be a variable number of arguments or a collection like a</span>
<span class="sd">            list or tuple. If not given, a single :obj:`so3_type` item will be returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        requires_grad (bool, optional): If autograd should record operations on</span>
<span class="sd">            the returned tensor. Default: False.</span>

<span class="sd">        generator (torch.Generator, optional): a pseudorandom number generator for sampling</span>

<span class="sd">        dtype (torch.dtype, optional): the desired data type of returned tensor.</span>
<span class="sd">            Default: if None, uses a global default (see :meth:`torch.set_default_tensor_type()`).</span>

<span class="sd">        layout (torch.layout, optional): the desired layout of returned Tensor.</span>
<span class="sd">            Default: torch.strided.</span>

<span class="sd">        device (torch.device, optional): the desired device of returned tensor.</span>
<span class="sd">            Default: if None, uses the current device for the default tensor</span>
<span class="sd">            type (see :meth:`torch.set_default_tensor_type()`). device will be the CPU</span>
<span class="sd">            for CPU tensor types and the current CUDA device for CUDA tensor types.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        LieTensor: a :obj:`so3_type` LieTensor</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; pp.identity_so3()</span>
<span class="sd">        so3Type LieTensor:</span>
<span class="sd">        tensor([0., 0., 0.])</span>

<span class="sd">        &gt;&gt;&gt; pp.identity_so3(2)</span>
<span class="sd">        so3Type LieTensor:</span>
<span class="sd">        tensor([[0., 0., 0.],</span>
<span class="sd">                [0., 0., 0.]])</span>

<span class="sd">        &gt;&gt;&gt; pp.identity_so3(2,1)</span>
<span class="sd">        so3Type LieTensor:</span>
<span class="sd">        tensor([[[0., 0., 0.]],</span>
<span class="sd">                [[0., 0., 0.]]])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">so3_type</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="identity_SE3"><a class="viewcode-back" href="../../../../generated/pypose.identity_SE3/#pypose.identity_SE3">[docs]</a><span class="k">def</span> <span class="nf">identity_SE3</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns identity :obj:`SE3_type` LieTensor with the given :obj:`lsize`.</span>
<span class="sd">    </span>
<span class="sd">    See :obj:`SE3()` for implementation details.</span>

<span class="sd">    Args:</span>
<span class="sd">        lsize (int..., optional): a sequence of integers defining the :obj:`LieTensor.lshape` of</span>
<span class="sd">            the output LieTensor. Can be a variable number of arguments or a collection like a</span>
<span class="sd">            list or tuple. If not given, a single :obj:`SE3_type` item will be returned.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>

<span class="sd">        requires_grad (bool, optional): If autograd should record operations on</span>
<span class="sd">            the returned tensor. Default: False.</span>

<span class="sd">        generator (torch.Generator, optional): a pseudorandom number generator for sampling</span>

<span class="sd">        dtype (torch.dtype, optional): the desired data type of returned tensor.</span>
<span class="sd">            Default: if None, uses a global default (see :meth:`torch.set_default_tensor_type()`).</span>

<span class="sd">        layout (torch.layout, optional): the desired layout of returned Tensor.</span>
<span class="sd">            Default: torch.strided.</span>

<span class="sd">        device (torch.device, optional): the desired device of returned tensor.</span>
<span class="sd">            Default: if None, uses the current device for the default tensor</span>
<span class="sd">            type (see :meth:`torch.set_default_tensor_type()`). device will be the CPU</span>
<span class="sd">            for CPU tensor types and the current CUDA device for CUDA tensor types.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        LieTensor: a :obj:`SE3_type` LieTensor</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; pp.identity_SE3()</span>
<span class="sd">        SE3Type LieTensor:</span>
<span class="sd">        tensor([0., 0., 0., 0., 0., 0., 1.])</span>

<span class="sd">        &gt;&gt;&gt; pp.identity_SE3(2)</span>
<span class="sd">        SE3Type LieTensor:</span>
<span class="sd">        tensor([[0., 0., 0., 0., 0., 0., 1.],</span>
<span class="sd">                [0., 0., 0., 0., 0., 0., 1.]])</span>

<span class="sd">        &gt;&gt;&gt; pp.identity_SE3(2,1)</span>
<span class="sd">        SE3Type LieTensor:</span>
<span class="sd">        tensor([[[0., 0., 0., 0., 0., 0., 1.]],</span>
<span class="sd">                [[0., 0., 0., 0., 0., 0., 1.]]])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">SE3_type</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="identity_se3"><a class="viewcode-back" href="../../../../generated/pypose.identity_se3/#pypose.identity_se3">[docs]</a><span class="k">def</span> <span class="nf">identity_se3</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns identity :obj:`se3_type` LieTensor with the given :obj:`lsize`.</span>
<span class="sd">    </span>
<span class="sd">    See :obj:`se3()` for implementation details.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        lsize (int..., optional): a sequence of integers defining the :obj:`LieTensor.lshape` of</span>
<span class="sd">            the output LieTensor. Can be a variable number of arguments or a collection like a</span>
<span class="sd">            list or tuple. If not given, a single :obj:`se3_type` item will be returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        requires_grad (bool, optional): If autograd should record operations on</span>
<span class="sd">            the returned tensor. Default: False.</span>

<span class="sd">        generator (torch.Generator, optional): a pseudorandom number generator for sampling</span>

<span class="sd">        dtype (torch.dtype, optional): the desired data type of returned tensor.</span>
<span class="sd">            Default: if None, uses a global default (see :meth:`torch.set_default_tensor_type()`).</span>

<span class="sd">        layout (torch.layout, optional): the desired layout of returned Tensor.</span>
<span class="sd">            Default: torch.strided.</span>

<span class="sd">        device (torch.device, optional): the desired device of returned tensor.</span>
<span class="sd">            Default: if None, uses the current device for the default tensor</span>
<span class="sd">            type (see :meth:`torch.set_default_tensor_type()`). device will be the CPU</span>
<span class="sd">            for CPU tensor types and the current CUDA device for CUDA tensor types.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        LieTensor: a :obj:`se3_type` LieTensor</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; pp.identity_se3()</span>
<span class="sd">        se3Type LieTensor:</span>
<span class="sd">        tensor([0., 0., 0., 0., 0., 0.])</span>

<span class="sd">        &gt;&gt;&gt; pp.identity_se3(2)</span>
<span class="sd">        se3Type LieTensor:</span>
<span class="sd">        tensor([[0., 0., 0., 0., 0., 0.],</span>
<span class="sd">                [0., 0., 0., 0., 0., 0.]])</span>

<span class="sd">        &gt;&gt;&gt; pp.identity_se3(2,1)</span>
<span class="sd">        se3Type LieTensor:</span>
<span class="sd">        tensor([[0., 0., 0., 0., 0., 0.],</span>
<span class="sd">                [0., 0., 0., 0., 0., 0.]])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">se3_type</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="identity_sim3"><a class="viewcode-back" href="../../../../generated/pypose.identity_sim3/#pypose.identity_sim3">[docs]</a><span class="k">def</span> <span class="nf">identity_sim3</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns identity :obj:`sim3_type` LieTensor with the given :obj:`lsize`.</span>
<span class="sd">    </span>
<span class="sd">    See :obj:`sim3()` for implementation details.</span>

<span class="sd">    Args:</span>
<span class="sd">        lsize (int..., optional): a sequence of integers defining the :obj:`LieTensor.lshape` of</span>
<span class="sd">            the output LieTensor. Can be a variable number of arguments or a collection like a</span>
<span class="sd">            list or tuple. If not given, a single :obj:`sim3_type` item will be returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        requires_grad (bool, optional): If autograd should record operations on</span>
<span class="sd">            the returned tensor. Default: False.</span>

<span class="sd">        generator (torch.Generator, optional): a pseudorandom number generator for sampling</span>

<span class="sd">        dtype (torch.dtype, optional): the desired data type of returned tensor.</span>
<span class="sd">            Default: if None, uses a global default (see :meth:`torch.set_default_tensor_type()`).</span>

<span class="sd">        layout (torch.layout, optional): the desired layout of returned Tensor.</span>
<span class="sd">            Default: torch.strided.</span>

<span class="sd">        device (torch.device, optional): the desired device of returned tensor.</span>
<span class="sd">            Default: if None, uses the current device for the default tensor</span>
<span class="sd">            type (see :meth:`torch.set_default_tensor_type()`). device will be the CPU</span>
<span class="sd">            for CPU tensor types and the current CUDA device for CUDA tensor types.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        LieTensor: a :obj:`sim3_type` LieTensor</span>
<span class="sd">        </span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; pp.identity_sim3()</span>
<span class="sd">        sim3Type LieTensor:</span>
<span class="sd">        tensor([0., 0., 0., 0., 0., 0., 0.])</span>

<span class="sd">        &gt;&gt;&gt; pp.identity_sim3(2)</span>
<span class="sd">        sim3Type LieTensor:</span>
<span class="sd">        tensor([[0., 0., 0., 0., 0., 0., 0.],</span>
<span class="sd">                [0., 0., 0., 0., 0., 0., 0.]])</span>

<span class="sd">        &gt;&gt;&gt; pp.identity_sim3(2,1)</span>
<span class="sd">        sim3Type LieTensor:</span>
<span class="sd">        tensor([[[0., 0., 0., 0., 0., 0., 0.]],</span>
<span class="sd">                [[0., 0., 0., 0., 0., 0., 0.]]])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">sim3_type</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="identity_Sim3"><a class="viewcode-back" href="../../../../generated/pypose.identity_Sim3/#pypose.identity_Sim3">[docs]</a><span class="k">def</span> <span class="nf">identity_Sim3</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns identity :obj:`Sim3_type` LieTensor with the given :obj:`lsize`.</span>
<span class="sd">    </span>
<span class="sd">    See :obj:`Sim3()` for implementation details.</span>

<span class="sd">    Args:</span>
<span class="sd">        lsize (int..., optional): a sequence of integers defining the :obj:`LieTensor.lshape` of</span>
<span class="sd">            the output LieTensor. Can be a variable number of arguments or a collection like a</span>
<span class="sd">            list or tuple. If not given, a single :obj:`Sim3_type` item will be returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        requires_grad (bool, optional): If autograd should record operations on</span>
<span class="sd">            the returned tensor. Default: False.</span>

<span class="sd">        generator (torch.Generator, optional): a pseudorandom number generator for sampling</span>

<span class="sd">        dtype (torch.dtype, optional): the desired data type of returned tensor.</span>
<span class="sd">            Default: if None, uses a global default (see :meth:`torch.set_default_tensor_type()`).</span>

<span class="sd">        layout (torch.layout, optional): the desired layout of returned Tensor.</span>
<span class="sd">            Default: torch.strided.</span>

<span class="sd">        device (torch.device, optional): the desired device of returned tensor.</span>
<span class="sd">            Default: if None, uses the current device for the default tensor</span>
<span class="sd">            type (see :meth:`torch.set_default_tensor_type()`). device will be the CPU</span>
<span class="sd">            for CPU tensor types and the current CUDA device for CUDA tensor types.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        LieTensor: a :obj:`Sim3_type` LieTensor</span>
<span class="sd">        </span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; pp.identity_Sim3()</span>
<span class="sd">        Sim3Type LieTensor:</span>
<span class="sd">        tensor([0., 0., 0., 0., 0., 0., 1., 1.])</span>

<span class="sd">        &gt;&gt;&gt; pp.identity_Sim3(2)</span>
<span class="sd">        Sim3Type LieTensor:</span>
<span class="sd">        tensor([[0., 0., 0., 0., 0., 0., 1., 1.],</span>
<span class="sd">                [0., 0., 0., 0., 0., 0., 1., 1.]])</span>

<span class="sd">        &gt;&gt;&gt; pp.identity_Sim3(2, 1)</span>
<span class="sd">        Sim3Type LieTensor:</span>
<span class="sd">        tensor([[[0., 0., 0., 0., 0., 0., 1., 1.]],</span>
<span class="sd">                [[0., 0., 0., 0., 0., 0., 1., 1.]]])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">Sim3_type</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="o">*</span><span class="n">lsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>    </div>


<div class="viewcode-block" id="identity_rxso3"><a class="viewcode-back" href="../../../../generated/pypose.identity_rxso3/#pypose.identity_rxso3">[docs]</a><span class="k">def</span> <span class="nf">identity_rxso3</span><span class="p">(</span><span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns identity :obj:`rxso3_type` LieTensor with the given :obj:`lsize`.</span>
<span class="sd">    </span>
<span class="sd">    See :obj:`rxSO3()` for implementation details.</span>

<span class="sd">    Args:</span>
<span class="sd">        lsize (int..., optional): a sequence of integers defining the :obj:`LieTensor.lshape` of</span>
<span class="sd">            the output LieTensor. Can be a variable number of arguments or a collection like a</span>
<span class="sd">            list or tuple. If not given, a single :obj:`rxso3_type` item will be returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        requires_grad (bool, optional): If autograd should record operations on</span>
<span class="sd">            the returned tensor. Default: False.</span>

<span class="sd">        generator (torch.Generator, optional): a pseudorandom number generator for sampling</span>

<span class="sd">        dtype (torch.dtype, optional): the desired data type of returned tensor.</span>
<span class="sd">            Default: if None, uses a global default (see :meth:`torch.set_default_tensor_type()`).</span>

<span class="sd">        layout (torch.layout, optional): the desired layout of returned Tensor.</span>
<span class="sd">            Default: torch.strided.</span>

<span class="sd">        device (torch.device, optional): the desired device of returned tensor.</span>
<span class="sd">            Default: if None, uses the current device for the default tensor</span>
<span class="sd">            type (see :meth:`torch.set_default_tensor_type()`). device will be the CPU</span>
<span class="sd">            for CPU tensor types and the current CUDA device for CUDA tensor types.</span>

<span class="sd">    Returns:</span>
<span class="sd">        LieTensor: a :obj:`rxso3_type` LieTensor</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; pp.identity_rxso3()</span>
<span class="sd">        rxso3Type LieTensor:</span>
<span class="sd">        tensor([0., 0., 0., 0.])</span>

<span class="sd">        &gt;&gt;&gt; pp.identity_rxso3(2)</span>
<span class="sd">        rxso3Type LieTensor:</span>
<span class="sd">        tensor([[0., 0., 0., 0.],</span>
<span class="sd">                [0., 0., 0., 0.]])</span>

<span class="sd">        &gt;&gt;&gt; pp.identity_rxso3(2, 1)</span>
<span class="sd">        rxso3Type LieTensor:</span>
<span class="sd">        tensor([[[0., 0., 0., 0.]],</span>
<span class="sd">                [[0., 0., 0., 0.]]])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">rxso3_type</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="identity_RxSO3"><a class="viewcode-back" href="../../../../generated/pypose.identity_RxSO3/#pypose.identity_RxSO3">[docs]</a><span class="k">def</span> <span class="nf">identity_RxSO3</span><span class="p">(</span><span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;Returns identity :obj:`RxSO3_type` LieTensor with the given :obj:`lsize`.</span>
<span class="sd">    </span>
<span class="sd">    See :obj:`RxSO3()` for implementation details.</span>

<span class="sd">    Args:</span>
<span class="sd">        lsize (int..., optional): a sequence of integers defining the :obj:`LieTensor.lshape` of</span>
<span class="sd">            the output LieTensor. Can be a variable number of arguments or a collection like a</span>
<span class="sd">            list or tuple. If not given, a single :obj:`RxSO3_type` item will be returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        requires_grad (bool, optional): If autograd should record operations on</span>
<span class="sd">            the returned tensor. Default: False.</span>

<span class="sd">        generator (torch.Generator, optional): a pseudorandom number generator for sampling</span>

<span class="sd">        dtype (torch.dtype, optional): the desired data type of returned tensor.</span>
<span class="sd">            Default: if None, uses a global default (see :meth:`torch.set_default_tensor_type()`).</span>

<span class="sd">        layout (torch.layout, optional): the desired layout of returned Tensor.</span>
<span class="sd">            Default: torch.strided.</span>

<span class="sd">        device (torch.device, optional): the desired device of returned tensor.</span>
<span class="sd">            Default: if None, uses the current device for the default tensor</span>
<span class="sd">            type (see :meth:`torch.set_default_tensor_type()`). device will be the CPU</span>
<span class="sd">            for CPU tensor types and the current CUDA device for CUDA tensor types.</span>

<span class="sd">    Returns:</span>
<span class="sd">        LieTensor: a :obj:`RxSO3_type` LieTensor</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; pp.identity_RxSO3()</span>
<span class="sd">        RxSO3Type LieTensor:</span>
<span class="sd">        tensor([0., 0., 0., 1., 1.])</span>

<span class="sd">        &gt;&gt;&gt; pp.identity_RxSO3(2)</span>
<span class="sd">        RxSO3Type LieTensor:</span>
<span class="sd">        tensor([[0., 0., 0., 1., 1.],</span>
<span class="sd">                [0., 0., 0., 1., 1.]])</span>

<span class="sd">        &gt;&gt;&gt; pp.identity_RxSO3(2, 1)</span>
<span class="sd">        RxSO3Type LieTensor:</span>
<span class="sd">        tensor([[[0., 0., 0., 1., 1.]],</span>
<span class="sd">                [[0., 0., 0., 1., 1.]]])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">RxSO3_type</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">assert_ltype</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">checker</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">LieTensor</span><span class="p">),</span> <span class="s2">&quot;Invalid LieTensor Type.&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
    <span class="k">return</span> <span class="n">checker</span>


<div class="viewcode-block" id="Exp"><a class="viewcode-back" href="../../../../generated/pypose.Exp/#pypose.Exp">[docs]</a><span class="nd">@assert_ltype</span>
<span class="k">def</span> <span class="nf">Exp</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The Exponential map for :obj:`LieTensor` (Lie Algebra).</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{Exp}: \mathcal{g} \mapsto \mathcal{G}</span>

<span class="sd">    Args:</span>
<span class="sd">        input (LieTensor): the input LieTensor (Lie Algebra)</span>

<span class="sd">    Return:</span>
<span class="sd">        LieTensor: the output LieTensor (Lie Group)</span>

<span class="sd">    .. list-table:: List of supported :math:`\mathrm{Exp}` map</span>
<span class="sd">        :widths: 20 20 8 20 20</span>
<span class="sd">        :header-rows: 1</span>

<span class="sd">        * - input :obj:`ltype`</span>
<span class="sd">          - :math:`\mathcal{g}` (Lie Algebra)</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{G}` (Lie Group)</span>
<span class="sd">          - output :obj:`ltype`</span>
<span class="sd">        * - :obj:`so3_type`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times3}`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{G}\in\mathbb{R}^{*\times4}`</span>
<span class="sd">          - :obj:`SO3_type`</span>
<span class="sd">        * - :obj:`se3_type`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times6}`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{G}\in\mathbb{R}^{*\times7}`</span>
<span class="sd">          - :obj:`SE3_type`</span>
<span class="sd">        * - :obj:`sim3_type`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times7}`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{G}\in\mathbb{R}^{*\times8}`</span>
<span class="sd">          - :obj:`Sim3_type`</span>
<span class="sd">        * - :obj:`rxso3_type`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times4}`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{G}\in\mathbb{R}^{*\times5}`</span>
<span class="sd">          - :obj:`RxSO3_type`</span>

<span class="sd">    Warning:</span>
<span class="sd">        This function :func:`Exp()` is different from :func:`exp()`, which returns</span>
<span class="sd">        a new torch tensor with the exponential of the elements of the input tensor.</span>

<span class="sd">    * Input :math:`\mathbf{x}`&#39;s :obj:`ltype` is :obj:`so3_type`</span>
<span class="sd">      (input :math:`\mathbf{x}` is an instance of :meth:`so3`):</span>

<span class="sd">        If :math:`\|\mathbf{x}_i\| &gt; \text{eps}`:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{y}_i = \left[\mathbf{x}_{i,1}\theta_i,</span>
<span class="sd">            \mathbf{x}_{i,2}\theta_i,</span>
<span class="sd">            \mathbf{x}_{i,3}\theta_i,</span>
<span class="sd">            \cos(\frac{\|\mathbf{x}_i\|}{2})\right],</span>

<span class="sd">        where :math:`\theta_i = \frac{1}{\|\mathbf{x}_i\|}\sin(\frac{\|\mathbf{x}_i\|}{2})`,</span>

<span class="sd">        otherwise:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{y}_i = \left[\mathbf{x}_{i,1}\theta_i,~</span>
<span class="sd">            \mathbf{x}_{i,2}\theta_i,~</span>
<span class="sd">            \mathbf{x}_{i,3}\theta_i,~</span>
<span class="sd">            1 - \frac{\|\mathbf{x}_i\|^2}{8} + \frac{\|\mathbf{x}_i\|^4}{384} \right],</span>

<span class="sd">        where :math:`\theta_i = \frac{1}{2} - \frac{1}{48} \|\mathbf{x}_i\|^2</span>
<span class="sd">        + \frac{1}{3840} \|\mathbf{x}_i\|^4`.</span>

<span class="sd">    * Input :math:`\mathbf{x}`&#39;s :obj:`ltype` is :obj:`se3_type`</span>
<span class="sd">      (input :math:`\mathbf{x}` is an instance of :meth:`se3`):</span>

<span class="sd">        Let :math:`\bm{\tau}_i`, :math:`\bm{\phi}_i` be the translation and rotation parts</span>
<span class="sd">        of :math:`\mathbf{x}_i`, respectively; :math:`\mathbf{y}` be the output.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{y}_i = \left[\mathbf{J}_i\bm{\tau}_i, \mathrm{Exp}(\bm{\phi}_i)\right],</span>
<span class="sd">        </span>
<span class="sd">        where :math:`\mathrm{Exp}` is the Exponential map for :obj:`so3_type` input and</span>
<span class="sd">        :math:`\mathbf{J}_i` is the left Jacobian for :obj:`so3_type` input.</span>

<span class="sd">    * Input :math:`\mathbf{x}`&#39;s :obj:`ltype` is :obj:`rxso3_type`</span>
<span class="sd">      (input :math:`\mathbf{x}` is an instance of :meth:`rxso3`):</span>

<span class="sd">        Let :math:`\bm{\phi}_i`, :math:`\sigma_i` be the rotation and scale parts of</span>
<span class="sd">        :math:`\mathbf{x}_i`, respectively; :math:`\mathbf{y}` be the output.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{y}_i = \left[\mathrm{Exp}(\bm{\phi}_i), \mathrm{exp}(\sigma_i)\right],</span>

<span class="sd">        where :math:`\mathrm{exp}` is the exponential function.</span>

<span class="sd">    * Input :math:`\mathbf{x}`&#39;s :obj:`ltype` is :obj:`sim3_type`</span>
<span class="sd">      (input :math:`\mathbf{x}` is an instance of :meth:`sim3`):</span>

<span class="sd">        Let :math:`\bm{\tau}_i`, :math:`^{s}\bm{\phi}_i` be the translation and</span>
<span class="sd">        :meth:`rxso3` parts of :math:`\mathbf{x}_i`, respectively.</span>
<span class="sd">        :math:`\bm{\phi}_i = \theta_i\mathbf{n}_i`, :math:`\sigma_i` be the rotation</span>
<span class="sd">        and scale parts of :math:`^{s}\bm{\phi}_i`, :math:`\boldsymbol{\Phi}_i` be the skew matrix</span>
<span class="sd">        of :math:`\bm{\phi}_i`; :math:`s_i = e^\sigma_i`, :math:`\mathbf{y}` be the output.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{y}_i = \left[^{s}\mathbf{W}_i\bm{\tau}_i, \mathrm{Exp}(^{s}\bm{\phi}_i)\right],</span>
<span class="sd">        </span>
<span class="sd">        where</span>

<span class="sd">        .. math::</span>
<span class="sd">            ^s\mathbf{W}_i = A\boldsymbol{\Phi}_i + B\boldsymbol{\Phi}_i^2 + C\mathbf{I}</span>

<span class="sd">        in which if :math:`\|\sigma_i\| \geq \text{eps}`:</span>

<span class="sd">        .. math::</span>
<span class="sd">            A = \left\{</span>
<span class="sd">                    \begin{array}{ll} </span>
<span class="sd">                        \frac{s_i\sin\theta_i\sigma_i + (1-s_i\cos\theta_i)\theta_i}</span>
<span class="sd">                        {\theta_i(\sigma_i^2 + \theta_i^2)}, \quad \|\theta_i\| \geq \text{eps}, \\</span>
<span class="sd">                        \frac{(\sigma_i-1)s_i+1}{\sigma_i^2}, \quad \|\theta_i\| &lt; \text{eps},</span>
<span class="sd">                    \end{array}</span>
<span class="sd">                \right.</span>

<span class="sd">        .. math::</span>
<span class="sd">            B = </span>
<span class="sd">            \left\{</span>
<span class="sd">                \begin{array}{ll} </span>
<span class="sd">                    \left( C - \frac{(s_i\cos\theta_i-1)\sigma+ s_i\sin\theta_i\sigma_i}</span>
<span class="sd">                    {\theta_i^2+\sigma_i^2}\right)\frac{1}{\theta_i^2}, \quad \|\theta_i\|</span>
<span class="sd">                        \geq \text{eps}, \\</span>
<span class="sd">                    \frac{s_i\sigma_i^2/2 + s_i-1-\sigma_i s_i}{\sigma_i^3}, \quad \|\theta_i\|</span>
<span class="sd">                        &lt; \text{eps},</span>
<span class="sd">                \end{array}</span>
<span class="sd">            \right.</span>

<span class="sd">        .. math::</span>
<span class="sd">            C = \frac{e^{\sigma_i} - 1}{\sigma_i}\mathbf{I}</span>

<span class="sd">        otherwise:</span>

<span class="sd">        .. math::</span>
<span class="sd">            A = \left\{</span>
<span class="sd">                    \begin{array}{ll} </span>
<span class="sd">                        \frac{1-\cos\theta_i}{\theta_i^2}, \quad \|\theta_i\| \geq \text{eps}, \\</span>
<span class="sd">                        \frac{1}{2}, \quad \|\theta_i\| &lt; \text{eps},</span>
<span class="sd">                    \end{array}</span>
<span class="sd">                \right.</span>

<span class="sd">        .. math::</span>
<span class="sd">            B = \left\{</span>
<span class="sd">                    \begin{array}{ll} </span>
<span class="sd">                        \frac{\theta_i - \sin\theta_i}{\theta_i^3}, \quad \|\theta_i\|</span>
<span class="sd">                            \geq \text{eps}, \\</span>
<span class="sd">                        \frac{1}{6}, \quad \|\theta_i\| &lt; \text{eps},</span>
<span class="sd">                    \end{array}</span>
<span class="sd">                \right.</span>

<span class="sd">        .. math::</span>
<span class="sd">            C = 1</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        The detailed explanation of the above :math:`\mathrm{Exp}`: calculation can be found</span>
<span class="sd">        in the paper:</span>

<span class="sd">        * Grassia, F. Sebastian., `Practical Parameterization of Rotations using the</span>
<span class="sd">          Exponential Map &lt;https://www.tandfonline.com/doi/pdf/10.1080/10867651.1998.10487493&gt;`_,</span>
<span class="sd">          Journal of graphics tools, 1998.</span>

<span class="sd">        Assume we have a unit rotation axis :math:`\mathbf{n}~(\|\mathbf{n}\|=1)` and rotation</span>
<span class="sd">        angle :math:`\theta~(0\leq\theta&lt;2\pi)`, let :math:`\mathbf{x}=\theta\mathbf{n}`, then</span>
<span class="sd">        the corresponding quaternion with unit norm :math:`\mathbf{q}` can be represented as:</span>

<span class="sd">            .. math::</span>
<span class="sd">                \mathbf{q} = \left[\frac{\sin(\theta/2)}{\theta} \mathbf{x}, \cos(\theta/2) \right].</span>

<span class="sd">        Given :math:`\mathbf{x}=\theta\mathbf{n}`, to find its corresponding quaternion</span>
<span class="sd">        :math:`\mathbf{q}`, we first calculate the rotation angle :math:`\theta` using:</span>

<span class="sd">            .. math::</span>
<span class="sd">                \theta = \|\mathbf{x}\|.</span>

<span class="sd">        Then, the corresponding quaternion is:</span>
<span class="sd">        </span>
<span class="sd">            .. math::</span>
<span class="sd">                \mathbf{q} = \left[\frac{\sin(\|\mathbf{x}\|/2)}{\|\mathbf{x}\|} \mathbf{x},</span>
<span class="sd">                    \cos(\|\mathbf{x}\|/2) \right].</span>

<span class="sd">        If :math:`\|\mathbf{x}\|` is small (:math:`\|\mathbf{x}\|\le \text{eps}`),</span>
<span class="sd">        we use the Taylor Expansion form of :math:`\sin(\|\mathbf{x}\|/2)` and</span>
<span class="sd">        :math:`\cos(\|\mathbf{x}\|/2)`.</span>

<span class="sd">        More details about :math:`^s\mathbf{W}_i` in :obj:`sim3_type` can be found in Eq. (5.7):</span>

<span class="sd">        * H. Strasdat, `Local Accuracy and Global Consistency for Efficient Visual SLAM</span>
<span class="sd">          &lt;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.640.199&amp;rep=rep1&amp;type=pdf&gt;`_,</span>
<span class="sd">          Dissertation. Department of Computing, Imperial College London, 2012.</span>

<span class="sd">    Examples:</span>

<span class="sd">        * :math:`\mathrm{Exp}`: :obj:`so3` :math:`\mapsto` :obj:`SO3`</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_so3()</span>
<span class="sd">            &gt;&gt;&gt; x.Exp() # equivalent to: pp.Exp(x)</span>
<span class="sd">            SO3Type LieTensor:</span>
<span class="sd">            LieTensor([-0.6627, -0.0447,  0.3492,  0.6610])</span>

<span class="sd">        * :math:`\mathrm{Exp}`: :obj:`se3` :math:`\mapsto` :obj:`SE3`</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_se3(2, requires_grad=True)</span>
<span class="sd">            se3Type LieTensor:</span>
<span class="sd">            tensor([[ 1.1912,  1.2425, -0.9696,  0.9540, -0.4061, -0.7204],</span>
<span class="sd">                    [ 0.5964, -1.1894,  0.6451,  1.1373, -2.6733,  0.4142]])</span>
<span class="sd">            &gt;&gt;&gt; x.Exp() # equivalent to: pp.Exp(x)</span>
<span class="sd">            SE3Type LieTensor:</span>
<span class="sd">            tensor([[ 1.6575,  0.8838, -0.1499,  0.4459, -0.1898, -0.3367,  0.8073],</span>
<span class="sd">                    [ 0.2654, -1.3860,  0.2852,  0.3855, -0.9061,  0.1404,  0.1034]],</span>
<span class="sd">                    grad_fn=&lt;AliasBackward0&gt;)</span>

<span class="sd">        * :math:`\mathrm{Exp}`: :obj:`rxso3` :math:`\mapsto` :obj:`RxSO3`</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_rxso3(2)</span>
<span class="sd">            &gt;&gt;&gt; x.Exp() # equivalent to: pp.Exp(x)</span>
<span class="sd">            RxSO3Type LieTensor:</span>
<span class="sd">            tensor([[-0.5633, -0.4281,  0.1112,  0.6979,  0.7408],</span>
<span class="sd">                    [ 0.5089,  0.2016, -0.2015,  0.8122,  1.1692]])</span>

<span class="sd">        * :math:`\mathrm{Exp}`: :obj:`sim3` :math:`\mapsto` :obj:`Sim3`</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_sim3(2)</span>
<span class="sd">            &gt;&gt;&gt; x.Exp() # equivalent to: pp.Exp(x)</span>
<span class="sd">            Sim3Type LieTensor:</span>
<span class="sd">            tensor([[-1.5811,  1.8128, -0.5835,  0.5849,  0.1142, -0.3438,  0.7257,  2.4443],</span>
<span class="sd">                    [ 0.9574, -0.9265, -0.2385, -0.7309, -0.3875,  0.1404,  0.5440,  1.1945]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">input</span><span class="o">.</span><span class="n">Exp</span><span class="p">()</span></div>


<div class="viewcode-block" id="Log"><a class="viewcode-back" href="../../../../generated/pypose.Log/#pypose.Log">[docs]</a><span class="nd">@assert_ltype</span>
<span class="k">def</span> <span class="nf">Log</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The Logarithm map for :obj:`LieTensor` (Lie Group).</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{Log}: \mathcal{G} \mapsto \mathcal{g}</span>

<span class="sd">    Args:</span>
<span class="sd">        input (LieTensor): the input LieTensor (Lie Group)</span>

<span class="sd">    Return:</span>
<span class="sd">        LieTensor: the output LieTensor (Lie Algebra)</span>

<span class="sd">    .. list-table:: List of supported :math:`\mathrm{Log}` map</span>
<span class="sd">        :widths: 20 20 8 20 20</span>
<span class="sd">        :header-rows: 1</span>

<span class="sd">        * - input :obj:`ltype`</span>
<span class="sd">          - :math:`\mathcal{G}` (Lie Group)</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{g}` (Lie Algebra)</span>
<span class="sd">          - output :obj:`ltype`</span>
<span class="sd">        * - :obj:`SO3_type`</span>
<span class="sd">          - :math:`\mathcal{G}\in\mathbb{R}^{*\times4}`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times3}`</span>
<span class="sd">          - :obj:`so3_type`</span>
<span class="sd">        * - :obj:`SE3_type`</span>
<span class="sd">          - :math:`\mathcal{G}\in\mathbb{R}^{*\times7}`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times6}`</span>
<span class="sd">          - :obj:`se3_type`</span>
<span class="sd">        * - :obj:`Sim3_type`</span>
<span class="sd">          - :math:`\mathcal{G}\in\mathbb{R}^{*\times8}`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times7}`</span>
<span class="sd">          - :obj:`sim3_type`</span>
<span class="sd">        * - :obj:`RxSO3_type`</span>
<span class="sd">          - :math:`\mathcal{G}\in\mathbb{R}^{*\times5}`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times4}`</span>
<span class="sd">          - :obj:`rxso3_type`</span>
<span class="sd">    </span>
<span class="sd">    Warning:</span>
<span class="sd">        This function :func:`Log()` is different from :func:`log()`, which returns</span>
<span class="sd">        a new torch tensor with the logarithm of the elements of the input tensor.</span>

<span class="sd">    * If input :math:`\mathbf{x}`&#39;s :obj:`ltype` is :obj:`SO3_type`</span>
<span class="sd">      (input :math:`\mathbf{x}` is an instance of :meth:`SO3`):</span>

<span class="sd">        Let :math:`w_i`, :math:`\boldsymbol{\nu}_i` be the scalar and vector parts of</span>
<span class="sd">        :math:`\mathbf{x}_i`, respectively; :math:`\mathbf{y}` be the output.</span>

<span class="sd">        If :math:`\|\boldsymbol{\nu}_i\| &gt; \text{eps}`:</span>

<span class="sd">            .. math::</span>
<span class="sd">                \mathbf{y}_i = </span>
<span class="sd">                    \left\{</span>
<span class="sd">                        \begin{array}{ll} </span>
<span class="sd">                            2\frac{\mathrm{arctan}(\|\boldsymbol{\nu}_i\|/w_i)}{\|</span>
<span class="sd">                            \boldsymbol{\nu}_i\|}\boldsymbol{\nu}_i, </span>
<span class="sd">                                \quad \|w_i\| &gt; \text{eps}, \\</span>
<span class="sd">                            \mathrm{sign}(w_i) \frac{\pi}{\|\boldsymbol{\nu}_i\|}</span>
<span class="sd">                                \boldsymbol{\nu}_i, \quad \|w_i\| \leq \text{eps},</span>
<span class="sd">                        \end{array}</span>
<span class="sd">                    \right.</span>

<span class="sd">        otherwise:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{y}_i = 2\left( \frac{1}{w_i} - </span>
<span class="sd">                \frac{\|\boldsymbol{\nu}_i\|^2}{3w_i^3}\right)\boldsymbol{\nu}_i.</span>

<span class="sd">    * If input :math:`\mathbf{x}`&#39;s :obj:`ltype` is :obj:`SE3_type`</span>
<span class="sd">      (input :math:`\mathbf{x}` is an instance of :meth:`SE3`):</span>

<span class="sd">        Let :math:`\mathbf{t}_i`, :math:`\mathbf{q}_i` be the translation and rotation parts of</span>
<span class="sd">        :math:`\mathbf{x}_i`, respectively; :math:`\mathbf{y}` be the output.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{y}_i = \left[\mathbf{J}_i^{-1}\mathbf{t}_i, \mathrm{Log}(\mathbf{q}_i) \right],</span>

<span class="sd">        where :math:`\mathrm{Log}` is the Logarithm map for :obj:`SO3_type` input and</span>
<span class="sd">        :math:`\mathbf{J}_i` is the left Jacobian for :obj:`SO3_type` input.</span>

<span class="sd">    * If input :math:`\mathbf{x}`&#39;s :obj:`ltype` is :obj:`RxSO3_type`</span>
<span class="sd">      (input :math:`\mathbf{x}` is an instance of :meth:`RxSO3`):</span>

<span class="sd">        Let :math:`\mathbf{q}_i`, :math:`s_i` be the rotation and scale parts of</span>
<span class="sd">        :math:`\mathbf{x}_i`, respectively; :math:`\mathbf{y}` be the output.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{y}_i = \left[\mathrm{Log}(\mathbf{q}_i), \log(s_i) \right].</span>

<span class="sd">    * If input :math:`\mathbf{x}`&#39;s :obj:`ltype` is :obj:`Sim3_type` (input :math:`\mathbf{x}`</span>
<span class="sd">      is an instance of :meth:`Sim3`):</span>

<span class="sd">        Let :math:`\mathbf{t}_i`, :math:`^s\mathbf{q}_i` be the translation and :obj:`RxSO3`</span>
<span class="sd">        parts of :math:`\mathbf{x}_i`, respectively; :math:`\boldsymbol{\phi}_i`,</span>
<span class="sd">        :math:`\sigma_i` be the corresponding Lie Algebra of the SO3 and scale part of</span>
<span class="sd">        :math:`^s\mathbf{q}_i`, :math:`\boldsymbol{\Phi}_i` be the skew matrix of</span>
<span class="sd">        :math:`\boldsymbol{\phi}_i`, :math:`\boldsymbol{\phi}_i` can be represented as</span>
<span class="sd">        :math:`\theta_i\mathbf{n}_i`, :math:`s_i = e^\sigma_i`, :math:`\mathbf{y}` be the</span>
<span class="sd">        output.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{y}_i = \left[^s\mathbf{W}_i^{-1}\mathbf{t}_i,</span>
<span class="sd">                \mathrm{Log}(^s\mathbf{q}_i) \right],</span>

<span class="sd">        where</span>

<span class="sd">            .. math::</span>
<span class="sd">               ^s\mathbf{W}_i = A\boldsymbol{\Phi}_i + B\boldsymbol{\Phi}_i^2 + C\mathbf{I}</span>

<span class="sd">        in which if :math:`\|\sigma_i\| &gt; \text{eps}`:</span>

<span class="sd">        .. math::</span>
<span class="sd">            A = \left\{</span>
<span class="sd">                    \begin{array}{ll} </span>
<span class="sd">                        \frac{s_i\sin\theta_i\sigma_i + (1-s_i\cos\theta_i)\theta_i}</span>
<span class="sd">                        {\theta_i(\sigma_i^2 + \theta_i^2)}, \quad \|\theta_i\| &gt; \text{eps}, \\</span>
<span class="sd">                        \frac{(\sigma_i-1)s_i+1}{\sigma_i^2}, \quad \|\theta_i\| \leq \text{eps},</span>
<span class="sd">                    \end{array}</span>
<span class="sd">                \right.</span>

<span class="sd">        .. math::</span>
<span class="sd">            B = </span>
<span class="sd">            \left\{</span>
<span class="sd">                \begin{array}{ll} </span>
<span class="sd">                    \left( C - \frac{(s_i\cos\theta_i-1)\sigma+ s_i\sin\theta_i\sigma_i}</span>
<span class="sd">                    {\theta_i^2+\sigma_i^2}\right)\frac{1}{\theta_i^2},</span>
<span class="sd">                        \quad \|\theta_i\| &gt; \text{eps}, \\</span>
<span class="sd">                    \frac{s_i\sigma_i^2/2 + s_i-1-\sigma_i s_i}{\sigma_i^3},</span>
<span class="sd">                        \quad \|\theta_i\| \leq \text{eps},</span>
<span class="sd">                \end{array}</span>
<span class="sd">            \right.</span>

<span class="sd">        .. math::</span>
<span class="sd">            C = \frac{e^{\sigma_i} - 1}{\sigma_i}\mathbf{I}</span>

<span class="sd">        otherwise:</span>

<span class="sd">        .. math::</span>
<span class="sd">            A = \left\{</span>
<span class="sd">                    \begin{array}{ll} </span>
<span class="sd">                        \frac{1-\cos\theta_i}{\theta_i^2}, \quad \|\theta_i\| &gt; \text{eps}, \\</span>
<span class="sd">                        \frac{1}{2}, \quad \|\theta_i\| \leq \text{eps},</span>
<span class="sd">                    \end{array}</span>
<span class="sd">                \right.</span>

<span class="sd">        .. math::</span>
<span class="sd">            B = \left\{</span>
<span class="sd">                    \begin{array}{ll} </span>
<span class="sd">                        \frac{\theta_i - \sin\theta_i}{\theta_i^3},</span>
<span class="sd">                            \quad \|\theta_i\| &gt; \text{eps}, \\</span>
<span class="sd">                        \frac{1}{6}, \quad \|\theta_i\| \leq \text{eps},</span>
<span class="sd">                    \end{array}</span>
<span class="sd">                \right.</span>

<span class="sd">        .. math::</span>
<span class="sd">            C = 1</span>

<span class="sd">    Note:</span>
<span class="sd">        The :math:`\mathrm{arctan}`-based Logarithm map implementation thanks to the paper:</span>

<span class="sd">        * C. Hertzberg et al., `Integrating Generic Sensor Fusion Algorithms with Sound State</span>
<span class="sd">          Representation through Encapsulation of Manifolds</span>
<span class="sd">          &lt;https://doi.org/10.1016/j.inffus.2011.08.003&gt;`_, Information Fusion, 2013.</span>

<span class="sd">        Assume we have a unit rotation axis :math:`\mathbf{n}` and rotation angle</span>
<span class="sd">        :math:`\theta~(0\leq\theta&lt;2\pi)`, then the corresponding quaternion with</span>
<span class="sd">        unit norm :math:`\mathbf{q}` can be represented as</span>

<span class="sd">            .. math::</span>
<span class="sd">                \mathbf{q} = \left[\sin(\theta/2) \mathbf{n}, \cos(\theta/2) \right]</span>

<span class="sd">        Therefore, given a quaternion :math:`\mathbf{q}=[\boldsymbol{\nu}, w]`, where</span>
<span class="sd">        :math:`\boldsymbol{\nu}` is the vector part, :math:`w` is the scalar part, to find</span>
<span class="sd">        the corresponding rotation vector, the rotation angle :math:`\theta` can be obtained as </span>

<span class="sd">            .. math::</span>
<span class="sd">                \theta = 2\mathrm{arctan}(\|\boldsymbol{\nu}\|/w),~\|\boldsymbol{\nu}\|</span>
<span class="sd">                = \sin(\theta/2), </span>

<span class="sd">        The unit rotation axis :math:`\mathbf{n}` can be obtained as :math:`\mathbf{n} =</span>
<span class="sd">        \frac{\boldsymbol{\nu}}{{\|\boldsymbol{\nu}\|}}`.</span>
<span class="sd">        Hence, the corresponding rotation vector is </span>

<span class="sd">            .. math::</span>
<span class="sd">                \theta \mathbf{n} = 2\frac{\mathrm{arctan}</span>
<span class="sd">                (\|\boldsymbol{\nu}\|/w)}{\|\boldsymbol{\nu}\|}\boldsymbol{\nu}.</span>

<span class="sd">        More details about :math:`^s\mathbf{W}_i` in :obj:`Sim3_type` can be found in Eq. (5.7):</span>

<span class="sd">        * H. Strasdat, `Local accuracy and global consistency for efficient visual SLAM</span>
<span class="sd">          &lt;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.640.199&amp;rep=rep1&amp;type=pdf&gt;`_, </span>
<span class="sd">          Dissertation. Department of Computing, Imperial College London, 2012.</span>

<span class="sd">    Example:</span>

<span class="sd">        * :math:`\mathrm{Log}`: :obj:`SO3` :math:`\mapsto` :obj:`so3`</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_SO3()</span>
<span class="sd">            &gt;&gt;&gt; x.Log() # equivalent to: pp.Log(x)</span>
<span class="sd">            so3Type LieTensor:</span>
<span class="sd">            tensor([-0.3060,  0.2344,  1.2724])</span>

<span class="sd">        * :math:`\mathrm{Log}`: :obj:`SE3` :math:`\mapsto` :obj:`se3`</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_SE3(2)</span>
<span class="sd">            &gt;&gt;&gt; x.Log() # equivalent to: pp.Log(x)</span>
<span class="sd">            se3Type LieTensor:</span>
<span class="sd">            tensor([[ 0.2958, -0.0840, -1.4733,  0.7004,  0.4483, -0.9009],</span>
<span class="sd">                    [ 0.0850, -0.1020, -1.2616, -1.0524, -1.2031,  0.8377]])</span>

<span class="sd">        * :math:`\mathrm{Log}`: :obj:`RxSO3` :math:`\mapsto` :obj:`rxso3`</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_RxSO3(2)</span>
<span class="sd">            &gt;&gt;&gt; x.Log() # equivalent to: pp.Log(x)</span>
<span class="sd">            rxso3Type LieTensor:</span>
<span class="sd">            tensor([[-1.3755,  0.3525, -2.2367,  0.5409],</span>
<span class="sd">                    [ 0.5929, -0.3250, -0.7394,  1.0965]])</span>

<span class="sd">        * :math:`\mathrm{Log}`: :obj:`Sim3` :math:`\mapsto` :obj:`sim3`</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_Sim3(2)</span>
<span class="sd">            &gt;&gt;&gt; x.Log() # equivalent to: pp.Log(x)</span>
<span class="sd">            sim3Type LieTensor:</span>
<span class="sd">            tensor([[-0.1747, -0.3698,  0.2000,  0.1735,  0.6220,  1.1852, -0.6402],</span>
<span class="sd">                    [-0.8685, -0.1717,  1.2139, -0.8385, -2.2957, -1.9545,  0.8474]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">input</span><span class="o">.</span><span class="n">Log</span><span class="p">()</span></div>


<div class="viewcode-block" id="Inv"><a class="viewcode-back" href="../../../../generated/pypose.Inv/#pypose.Inv">[docs]</a><span class="nd">@assert_ltype</span>
<span class="k">def</span> <span class="nf">Inv</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The inverse of the input lieTensor.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{Inv}: Y_i = X_i^{-1}</span>

<span class="sd">    Args:</span>
<span class="sd">        input (LieTensor): the input LieTensor (Lie Group or Lie Algebra)</span>

<span class="sd">    Return:</span>
<span class="sd">        LieTensor: the output LieTensor (Lie Group or Lie Algebra)</span>

<span class="sd">    .. list-table:: List of supported :math:`\mathrm{Inv}` map</span>
<span class="sd">        :widths: 20 20 8 20 20</span>
<span class="sd">        :header-rows: 1</span>

<span class="sd">        * - input :obj:`ltype`</span>
<span class="sd">          - LieTensor</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - LieTensor</span>
<span class="sd">          - output :obj:`ltype`</span>
<span class="sd">        * - :obj:`SO3_type`</span>
<span class="sd">          - :math:`\mathcal{G}\in\mathbb{R}^{*\times4}`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{G}\in\mathbb{R}^{*\times4}`</span>
<span class="sd">          - :obj:`SO3_type`</span>
<span class="sd">        * - :obj:`SE3_type`</span>
<span class="sd">          - :math:`\mathcal{G}\in\mathbb{R}^{*\times7}`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{G}\in\mathbb{R}^{*\times7}`</span>
<span class="sd">          - :obj:`SE3_type`</span>
<span class="sd">        * - :obj:`Sim3_type`</span>
<span class="sd">          - :math:`\mathcal{G}\in\mathbb{R}^{*\times8}`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{G}\in\mathbb{R}^{*\times8}`</span>
<span class="sd">          - :obj:`Sim3_type`</span>
<span class="sd">        * - :obj:`RxSO3_type`</span>
<span class="sd">          - :math:`\mathcal{G}\in\mathbb{R}^{*\times5}`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{G}\in\mathbb{R}^{*\times5}`</span>
<span class="sd">          - :obj:`RxSO3_type`</span>
<span class="sd">        * - :obj:`so3_type`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times3}`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times3}`</span>
<span class="sd">          - :obj:`so3_type`</span>
<span class="sd">        * - :obj:`se3_type`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times6}`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times6}`</span>
<span class="sd">          - :obj:`se3_type`</span>
<span class="sd">        * - :obj:`sim3_type`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times7}`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times7}`</span>
<span class="sd">          - :obj:`sim3_type`</span>
<span class="sd">        * - :obj:`rxso3_type`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times4}`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times4}`</span>
<span class="sd">          - :obj:`rxso3_type`</span>

<span class="sd">    * If input :math:`\mathbf{x}`&#39;s :obj:`ltype` is :obj:`SO3_type`</span>
<span class="sd">      (input :math:`\mathbf{x}` is an instance of :meth:`SO3`):</span>

<span class="sd">        Let :math:`w_i`, :math:`\boldsymbol{\nu}_i` be the scalar and vector parts of</span>
<span class="sd">        :math:`\mathbf{x}_i`, respectively. :math:`\mathbf{x}_i=\left[\boldsymbol{\nu}_i,</span>
<span class="sd">        \ w_i \right]`. :math:`\mathbf{y}` be the output.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{y}_i = \mathrm{conj}(\mathbf{x}_i)=[-\boldsymbol{\nu}_i, \ w_i]</span>

<span class="sd">    * If input :math:`\mathbf{x}`&#39;s :obj:`ltype` is :obj:`SE3_type`</span>
<span class="sd">      (input :math:`\mathbf{x}` is an instance of :meth:`SE3`):</span>

<span class="sd">        Let :math:`\mathbf{t}_i`, :math:`\mathbf{q}_i` be the translation and rotation parts of</span>
<span class="sd">        :math:`\mathbf{x}_i`, respectively; :math:`\mathbf{y}` be the output.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{y}_i = \left[-\mathrm{Inv}(\mathbf{q}_i)*\mathbf{t}_i,</span>
<span class="sd">            \mathrm{Inv}(\mathbf{q}_i) \right]</span>

<span class="sd">    * If input :math:`\mathbf{x}`&#39;s :obj:`ltype` is :obj:`RxSO3_type`</span>
<span class="sd">      (input :math:`\mathbf{x}` is an instance of :meth:`RxSO3`):</span>

<span class="sd">        Let :math:`\mathbf{q}_i`, :math:`s_i` be the rotation and scale parts of</span>
<span class="sd">        :math:`\mathbf{x}_i`, respectively; :math:`\mathbf{y}` be the output.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{y}_i = \left[\mathrm{conj}(\mathbf{q}_i), \ 1/s_i \right]</span>

<span class="sd">    * If input :math:`\mathbf{x}`&#39;s :obj:`ltype` is :obj:`Sim3_type` (input :math:`\mathbf{x}`</span>
<span class="sd">      is an instance of :meth:`Sim3`):</span>

<span class="sd">        Let :math:`\mathbf{t}_i`, :math:`^s\mathbf{q}_i` be the translation and :obj:`RxSO3` parts</span>
<span class="sd">        of :math:`\mathbf{x}_i`, respectively;  :math:`\mathbf{y}` be the output.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{y}_i = \left[-\mathrm{Inv}(^s\mathbf{q}_i)*\mathbf{t}_i, </span>
<span class="sd">            \mathrm{Inv}(^s\mathbf{q}_i) \right]</span>

<span class="sd">    * If input :math:`\mathbf{x}`&#39;s :obj:`ltype` is :obj:`so3_type` or :obj:`se3_type` or</span>
<span class="sd">      :obj:`sim3_type` or :obj:`rxso3_type` (input :math:`\mathbf{x}` is an instance of :meth:`so3`</span>
<span class="sd">      or :meth:`se3` or :meth:`sim3` or :meth:`rxso3`):</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{y}_i = -\mathbf{x}_i</span>

<span class="sd">    Example:</span>

<span class="sd">        * :math:`\mathrm{Inv}`: :obj:`SO3` :math:`\mapsto` :obj:`SO3`</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_SO3()</span>
<span class="sd">            SO3Type LieTensor:</span>
<span class="sd">            tensor([-0.1402, -0.2827,  0.2996,  0.9004])</span>
<span class="sd">            &gt;&gt;&gt; x.Inv() # equivalent to: pp.Inv(x)</span>
<span class="sd">            SO3Type LieTensor:</span>
<span class="sd">            tensor([ 0.1402,  0.2827, -0.2996,  0.9004])</span>

<span class="sd">        * :math:`\mathrm{Inv}`: :obj:`SE3` :math:`\mapsto` :obj:`SE3`</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_SE3()</span>
<span class="sd">            SE3Type LieTensor:</span>
<span class="sd">            tensor([ 0.6074, -0.7596,  0.8703, -0.3092,  0.2932,  0.9027,  0.0598])</span>
<span class="sd">            &gt;&gt;&gt; x.Inv() # equivalent to: pp.Inv(x)</span>
<span class="sd">            SE3Type LieTensor:</span>
<span class="sd">            tensor([ 0.9475, -0.8764,  0.1938,  0.3092, -0.2932, -0.9027,  0.0598])</span>

<span class="sd">        * :math:`\mathrm{Inv}`: :obj:`RxSO3` :math:`\mapsto` :obj:`RxSO3`</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_RxSO3()</span>
<span class="sd">            RxSO3Type LieTensor:</span>
<span class="sd">            tensor([-0.5103,  0.4707, -0.3494,  0.6292,  0.9199])</span>
<span class="sd">            &gt;&gt;&gt; x.Inv() # equivalent to: pp.Inv(x)</span>
<span class="sd">            RxSO3Type LieTensor:</span>
<span class="sd">            tensor([ 0.5103, -0.4707,  0.3494,  0.6292,  1.0871])</span>

<span class="sd">        * :math:`\mathrm{Inv}`: :obj:`Sim3` :math:`\mapsto` :obj:`Sim3`</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_Sim3()</span>
<span class="sd">            Sim3Type LieTensor:</span>
<span class="sd">            tensor([ 0.7056,  1.3140, -0.1995, -0.2444, -0.5250,  0.5504,  0.6014,  1.0543])</span>
<span class="sd">            &gt;&gt;&gt; x.Inv() # equivalent to: pp.Inv(x)</span>
<span class="sd">            Sim3Type LieTensor:</span>
<span class="sd">            tensor([-0.9712, -0.2361,  1.0188,  0.2444,  0.5250, -0.5504,  0.6014,  0.9485])</span>

<span class="sd">        * :math:`\mathrm{Inv}`: :obj:`so3` :math:`\mapsto` :obj:`so3`</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_so3()</span>
<span class="sd">            so3Type LieTensor:</span>
<span class="sd">            tensor([ 0.0612, -0.7190,  2.6897])</span>
<span class="sd">            &gt;&gt;&gt; x.Inv() # equivalent to: pp.Inv(x)</span>
<span class="sd">            so3Type LieTensor:</span>
<span class="sd">            tensor([-0.0612,  0.7190, -2.6897])</span>

<span class="sd">        * :math:`\mathrm{Inv}`: :obj:`se3` :math:`\mapsto` :obj:`se3`</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_se3()</span>
<span class="sd">            se3Type LieTensor:</span>
<span class="sd">            tensor([ 0.2837, -1.8318,  1.0104,  2.2385, -0.1980, -0.9487])</span>
<span class="sd">            &gt;&gt;&gt; x.Inv() # equivalent to: pp.Inv(x)</span>
<span class="sd">            se3Type LieTensor:</span>
<span class="sd">            tensor([-0.2837,  1.8318, -1.0104, -2.2385,  0.1980,  0.9487])</span>

<span class="sd">        * :math:`\mathrm{Inv}`: :obj:`rxso3` :math:`\mapsto` :obj:`rxso3`</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_rxso3()</span>
<span class="sd">            rxso3Type LieTensor:</span>
<span class="sd">            tensor([ 1.0414, -0.0087, -0.4427, -1.1343])</span>
<span class="sd">            &gt;&gt;&gt; x.Inv() # equivalent to: pp.Inv(x)</span>
<span class="sd">            rxso3Type LieTensor:</span>
<span class="sd">            tensor([-1.0414,  0.0087,  0.4427,  1.1343])</span>

<span class="sd">        * :math:`\mathrm{Inv}`: :obj:`sim3` :math:`\mapsto` :obj:`sim3`</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_sim3()</span>
<span class="sd">            sim3Type LieTensor:</span>
<span class="sd">            tensor([-0.0724,  1.8174,  2.1810, -0.9324, -0.0952, -0.5792,  0.4318])</span>
<span class="sd">            &gt;&gt;&gt; x.Inv() # equivalent to: pp.Inv(x)</span>
<span class="sd">            sim3Type LieTensor:</span>
<span class="sd">            tensor([ 0.0724, -1.8174, -2.1810,  0.9324,  0.0952,  0.5792, -0.4318])</span>

<span class="sd">    Note:</span>
<span class="sd">        Mathematically, only Lie Group has an inverse. For the convenience, we also provide the</span>
<span class="sd">        inverse for the corresponding Lie Algebra. One can validate the results by:</span>

<span class="sd">        if input :math:`\mathbf{x}` is the LieTensor from Lie Group, for example</span>
<span class="sd">        :math:`\mathbf{x}`&#39;s :obj:`ltype` is :obj:`SO3_type` :</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_SO3()</span>
<span class="sd">            &gt;&gt;&gt; x * x.Inv()</span>
<span class="sd">            SO3Type LieTensor:</span>
<span class="sd">            LieTensor([0., 0., 0., 1.])</span>

<span class="sd">        if input :math:`\mathbf{x}` is the LieTensor from Lie Algebra, for example</span>
<span class="sd">        :math:`\mathbf{x}`&#39;s :obj:`ltype` is :obj:`so3_type` :</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_so3()</span>
<span class="sd">            &gt;&gt;&gt; x + x.Inv()</span>
<span class="sd">            tensor([0., 0., 0.])</span>

<span class="sd">        One can also verify:</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_SO3()</span>
<span class="sd">            &gt;&gt;&gt; x.Log() + x.Inv().Log()</span>
<span class="sd">            so3Type LieTensor:</span>
<span class="sd">            LieTensor([0., 0., 0.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">Inv</span><span class="p">()</span></div>


<span class="nd">@assert_ltype</span>
<span class="k">def</span> <span class="nf">Mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">@</span> <span class="n">y</span>


<div class="viewcode-block" id="Retr"><a class="viewcode-back" href="../../../../generated/pypose.Retr/#pypose.Retr">[docs]</a><span class="nd">@assert_ltype</span>
<span class="k">def</span> <span class="nf">Retr</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Perform batched retraction with a given direction.</span>

<span class="sd">    .. math::</span>
<span class="sd">        Y_i = \mathrm{Exp}(a_i) * X_i,</span>

<span class="sd">    where :math:`\mathrm{Exp}` means the exponetial map. See :obj:`pypose.Exp` for more details. </span>

<span class="sd">    Args:</span>
<span class="sd">        X (LieTensor): the input LieTensor to retract (Lie Group)</span>

<span class="sd">        a (LieTensor): the direction of the retraction (Lie Algebra)</span>

<span class="sd">    Return:</span>
<span class="sd">        LieTensor: The retraction of the inputs (Lie Group)</span>

<span class="sd">    Examples:</span>

<span class="sd">        * :math:`\mathrm{Retr}`: (:obj:`SO3`, :obj:`so3`) :math:`\mapsto` :obj:`SO3`</span>

<span class="sd">            &gt;&gt;&gt; a = pp.randn_so3()</span>
<span class="sd">            &gt;&gt;&gt; X = pp.randn_SO3()</span>
<span class="sd">            &gt;&gt;&gt; X.Retr(a) # equivalent to: pp.Retr(X, a)</span>
<span class="sd">            SO3Type LieTensor:</span>
<span class="sd">            tensor([0.6399, 0.0898, 0.1656, 0.7451])</span>

<span class="sd">        * :math:`\mathrm{Retr}`: (:obj:`SE3`, :obj:`se3`) :math:`\mapsto` :obj:`SE3`</span>

<span class="sd">            &gt;&gt;&gt; a = pp.randn_se3()</span>
<span class="sd">            &gt;&gt;&gt; X = pp.randn_SE3()</span>
<span class="sd">            &gt;&gt;&gt; X.Retr(a)  # equivalent to: pp.Retr(X, a)</span>
<span class="sd">            SE3Type LieTensor:</span>
<span class="sd">            tensor([-0.6754,  1.8240,  0.2109, -0.4649, -0.7254, -0.0943,  0.4987])</span>

<span class="sd">        * :math:`\mathrm{Retr}`: (:obj:`Sim3`, :obj:`sim3`) :math:`\mapsto` :obj:`Sim3`</span>

<span class="sd">            &gt;&gt;&gt; a = pp.randn_sim3()</span>
<span class="sd">            &gt;&gt;&gt; X = pp.randn_Sim3()</span>
<span class="sd">            &gt;&gt;&gt; X.Retr(a)  # equivalent to: pp.Retr(X, a)</span>
<span class="sd">            Sim3Type LieTensor:</span>
<span class="sd">            tensor([-0.6057, -1.6370,  1.1379,  0.7037,  0.6164,  0.3525, -0.0262,  0.3141])</span>

<span class="sd">        * :math:`\mathrm{Retr}`: (:obj:`RxSO3`, :obj:`rxsso3`) :math:`\mapsto` :obj:`RxSO3`</span>

<span class="sd">            &gt;&gt;&gt; a = pp.randn_rxso3()</span>
<span class="sd">            &gt;&gt;&gt; X = pp.randn_RxSO3()</span>
<span class="sd">            &gt;&gt;&gt; X.Retr(a)  # equivalent to: pp.Retr(X, a)</span>
<span class="sd">            RxSO3Type LieTensor:</span>
<span class="sd">            tensor([-0.0787,  0.4052, -0.7509,  0.5155,  0.1217])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">Retr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></div>


<div class="viewcode-block" id="Act"><a class="viewcode-back" href="../../../../generated/pypose.Act/#pypose.Act">[docs]</a><span class="nd">@assert_ltype</span>
<span class="k">def</span> <span class="nf">Act</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply the batched transform to points in Euclidean or homogeneous coordinates.</span>

<span class="sd">    .. math::</span>
<span class="sd">        y_i = X_i * p_i,</span>

<span class="sd">    where :math:`X` is the batched transform and :math:`p_i \in \mathbb{R^{*\times3}}` or</span>
<span class="sd">    :math:`p_i \in \mathbb{R^{*\times4}}` denotes the points to be transformed.</span>

<span class="sd">    Args:</span>
<span class="sd">        X (LieTensor): the input LieTensor (Lie Group).</span>

<span class="sd">        p (Tensor): the points to be transformed.</span>

<span class="sd">    Return:</span>
<span class="sd">        Tensor: the transformed points in Euclidean or homogeneous coordinates.</span>

<span class="sd">    Examples:</span>

<span class="sd">        * :math:`\mathrm{Act}`: (:obj:`SO3`, :obj:`Tensor`) :math:`\mapsto` :obj:`Tensor`</span>

<span class="sd">            &gt;&gt;&gt; p = torch.randn(3)     # batch size 1, Euclidean coordinates</span>
<span class="sd">            &gt;&gt;&gt; X = pp.identity_SO3(2) # batch size 2</span>
<span class="sd">            &gt;&gt;&gt; X.Act(p)               # equivalent to: pp.Act(X, p)</span>
<span class="sd">            tensor([[ 1.7576,  1.1503, -0.9920],</span>
<span class="sd">                    [ 1.7576,  1.1503, -0.9920]])</span>

<span class="sd">        * :math:`\mathrm{Act}`: (:obj:`SE3`, :obj:`Tensor`) :math:`\mapsto` :obj:`Tensor`</span>

<span class="sd">            &gt;&gt;&gt; p = torch.tensor([[0, 0, 0, 1.], [0, 0, 0, 1.]]) # batch size 2, homogeneous coordinates</span>
<span class="sd">            &gt;&gt;&gt; X = pp.randn_SE3()                               # batch size 1</span>
<span class="sd">            &gt;&gt;&gt; X.Act(p)                                         # apply same transform</span>
<span class="sd">            tensor([[-0.5676, -0.0452, -0.0929,  1.0000],</span>
<span class="sd">                    [-0.5676, -0.0452, -0.0929,  1.0000]])</span>

<span class="sd">        * :math:`\mathrm{Act}`: (:obj:`Sim3`, :obj:`Tensor`) :math:`\mapsto` :obj:`Tensor`</span>

<span class="sd">            &gt;&gt;&gt; p = torch.tensor([[0, 0, 0, 1.], [0, 0, 0, 1.]])  # batch size 2</span>
<span class="sd">            &gt;&gt;&gt; X = pp.randn_Sim3(2)                              # batch size 2</span>
<span class="sd">            &gt;&gt;&gt; X.Act(p)                                          # apply transform respectively.</span>
<span class="sd">            tensor([[ 0.1551,  2.2930,  0.4531,  1.0000],</span>
<span class="sd">                    [-0.6140, -1.1263,  2.7607,  1.0000]])</span>

<span class="sd">        * :math:`\mathrm{Act}`: (:obj:`RxSO3`, :obj:`Tensor`) :math:`\mapsto` :obj:`Tensor`</span>

<span class="sd">            &gt;&gt;&gt; p = torch.tensor([[0, 0, 0.], [0, 0, 0.]])  # batch size 2, Euclidean coordinates</span>
<span class="sd">            &gt;&gt;&gt; X = pp.randn_RxSO3(2)                       # batch size 2</span>
<span class="sd">            &gt;&gt;&gt; X.Act(p)                                    # apply transform respectively.</span>
<span class="sd">            tensor([[0., 0., 0.],</span>
<span class="sd">                    [0., 0., 0.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">Act</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></div>


<div class="viewcode-block" id="Adj"><a class="viewcode-back" href="../../../../generated/pypose.Adj/#pypose.Adj">[docs]</a><span class="nd">@assert_ltype</span>
<span class="k">def</span> <span class="nf">Adj</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The dot product between the Adjoint matrix at the point given by an input (Lie Group) and </span>
<span class="sd">    the second point (Lie Algebra).</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{Adj}: (\mathcal{G}, \mathcal{g}) \mapsto \mathcal{g}</span>

<span class="sd">    Args:</span>
<span class="sd">        input (LieTensor): the input LieTensor (Lie Group)</span>
<span class="sd">        p (LieTensor): the second LieTensor (Lie Algebra)</span>

<span class="sd">    Return:</span>
<span class="sd">        LieTensor: the output LieTensor (Lie Algebra)</span>

<span class="sd">    .. list-table:: List of supported :math:`\mathrm{Adj}` map</span>
<span class="sd">        :widths: 20 20 8 20 20</span>
<span class="sd">        :header-rows: 1</span>

<span class="sd">        * - input :obj:`ltype`</span>
<span class="sd">          - :math:`(\mathcal{G}, \mathcal{g})` (Lie Group, Lie Algebra)</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{g}` (Lie Algebra)</span>
<span class="sd">          - output :obj:`ltype`</span>
<span class="sd">        * - (:obj:`SO3_type`, :obj:`so3_type`)</span>
<span class="sd">          - :math:`(\mathcal{G}\in\mathbb{R}^{*\times4}, \mathcal{g}\in\mathbb{R}^{*\times3})`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times3}`</span>
<span class="sd">          - :obj:`so3_type`</span>
<span class="sd">        * - (:obj:`SE3_type`, :obj:`se3_type`)</span>
<span class="sd">          - :math:`(\mathcal{G}\in\mathbb{R}^{*\times7}, \mathcal{g}\in\mathbb{R}^{*\times6})`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times6}`</span>
<span class="sd">          - :obj:`se3_type`</span>
<span class="sd">        * - (:obj:`Sim3_type`, :obj:`sim3_type`)</span>
<span class="sd">          - :math:`(\mathcal{G}\in\mathbb{R}^{*\times8}, \mathcal{g}\in\mathbb{R}^{*\times7})`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times7}`</span>
<span class="sd">          - :obj:`sim3_type`</span>
<span class="sd">        * - (:obj:`RxSO3_type`, :obj:`rxso3_type`)</span>
<span class="sd">          - :math:`(\mathcal{G}\in\mathbb{R}^{*\times5}, \mathcal{g}\in\mathbb{R}^{*\times4})`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times4}`</span>
<span class="sd">          - :obj:`rxso3_type` </span>

<span class="sd">    Let the input be (:math:`\mathbf{x}`, :math:`\mathbf{p}`), :math:`\mathbf{y}` be the output.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{y}_i = \mathrm{Adj}(\mathbf{x}_i)\mathbf{p}_i,</span>

<span class="sd">        where, :math:`\mathrm{Adj}(\mathbf{x}_i)` is the adjoint matrix of the Lie group of</span>
<span class="sd">        :math:`\mathbf{x}_i`.</span>

<span class="sd">    * If input (:math:`\mathbf{x}`, :math:`\mathbf{p}`)&#39;s :obj:`ltype` are :obj:`SO3_type` and</span>
<span class="sd">      :obj:`so3_type` (input :math:`\mathbf{x}` is an instance of :meth:`SO3`, :math:`\mathbf{p}`</span>
<span class="sd">      is an instance of :meth:`so3`). Given :math:`\mathbf{x}_i \in` :math:`\textrm{SO(3)}`.</span>
<span class="sd">      The adjoint transformation is given by:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{Adj}(\mathbf{x}_i) = \mathbf{x}_i </span>

<span class="sd">        In the case of :math:`\textrm{SO3}`, the adjoint transformation for an element is the same</span>
<span class="sd">        rotation matrix used to represent the element. Rotating a tangent vector by an element</span>
<span class="sd">        &quot;moves&quot; it from the tangent space on the right side of the element to the tangent space on</span>
<span class="sd">        the left.</span>

<span class="sd">    * If input (:math:`\mathbf{x}`, :math:`\mathbf{p}`)&#39;s :obj:`ltype` are :obj:`SE3_type`</span>
<span class="sd">      and :obj:`se3_type` (input :math:`\mathbf{x}` is an instance of :meth:`SE3`,</span>
<span class="sd">      :math:`\mathbf{p}` is an instance of :meth:`se3`). Let :math:`\mathbf{R}_i \in`</span>
<span class="sd">      :math:`\textrm{SO(3)}` and :math:`\mathbf{t}_i \in \mathbb{R}^{3\times3}` represent the</span>
<span class="sd">      rotation and translation part of the group. Let :math:`\mathbf{t}_{i\times}` be the skew</span>
<span class="sd">      matrix (:meth:`pypose.vec2skew`) of :math:`\mathbf{t}_i`.</span>
<span class="sd">      The adjoint transformation is given by:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{Adj}(\mathbf{x}_i) = \left[</span>
<span class="sd">                                \begin{array}{cc} </span>
<span class="sd">                                    \mathbf{R}_i &amp; \mathbf{t}_{i\times}\mathbf{R}_i \\</span>
<span class="sd">                                    0 &amp; \mathbf{R}_i</span>
<span class="sd">                                \end{array}</span>
<span class="sd">                             \right] \in \mathbb{R}^{6\times6}</span>

<span class="sd">        where,</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{x}_i = \left[</span>
<span class="sd">                                \begin{array}{cc} </span>
<span class="sd">                                    \mathbf{R}_i&amp; \mathbf{t}_i \\</span>
<span class="sd">                                    0 &amp; 1</span>
<span class="sd">                                \end{array}</span>
<span class="sd">                             \right] \in \mathrm{SE(3)}  </span>

<span class="sd">    * If input (:math:`\mathbf{x}`, :math:`\mathbf{p}`)&#39;s :obj:`ltype` are :obj:`Sim3_type` and</span>
<span class="sd">      :obj:`sim3_type` (input :math:`\mathbf{x}` is an instance of :meth:`Sim3`, :math:`\mathbf{p}`</span>
<span class="sd">      is an instance of :meth:`sim3`). Let :math:`\mathbf{R}_i\in` :math:`\textrm{SO(3)}`,</span>
<span class="sd">      :math:`\mathbf{t}_i \in \mathbb{R}^{3\times3}`, and :math:`s_i \in \mathbb{R}^+` represent</span>
<span class="sd">      the rotation, translation, and scale parts of the group. Let :math:`\mathbf{t}_{i\times}`</span>
<span class="sd">      be the skew matrix (:meth:`pypose.vec2skew`) of :math:`\mathbf{t}_i`. The adjoint</span>
<span class="sd">      transformation is given by:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{Adj}(\mathbf{x}_i) = \left[</span>
<span class="sd">                        \begin{array}{cc} </span>
<span class="sd">                            s_i\mathbf{R}_i&amp; \mathbf{t}_{i\times}\mathbf{R}_i&amp; -\mathbf{t}_i \\</span>
<span class="sd">                            0 &amp; \mathbf{R}_i&amp; 0 \\</span>
<span class="sd">                            0 &amp; 0 &amp; 1</span>
<span class="sd">                        \end{array}</span>
<span class="sd">                        \right] \in \mathbb{R}^{7\times7}</span>

<span class="sd">        where,</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{x}_i = \left[</span>
<span class="sd">                                \begin{array}{cc} </span>
<span class="sd">                                    s_i\mathbf{R}_i &amp; \mathbf{t}_i \\</span>
<span class="sd">                                    0 &amp; 1</span>
<span class="sd">                                \end{array}</span>
<span class="sd">                             \right] \in \textrm{Sim(3)}    </span>

<span class="sd">    * If input (:math:`\mathbf{x}`, :math:`\mathbf{p}`)&#39;s :obj:`ltype` are :obj:`RxSO3_type`</span>
<span class="sd">      and :obj:`rxso3_type` (input :math:`\mathbf{x}` is an instance of :meth:`RxSO3`,</span>
<span class="sd">      :math:`\mathbf{p}` is an instance of :meth:`rxso3`). Let :math:`\mathbf{R}_i \in`</span>
<span class="sd">      :math:`\textrm{SO(3)}`, and :math:`s_i \in \mathbb{R}^+` represent the rotation and</span>
<span class="sd">      scale parts of the group. The adjoint transformation is given by:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{Adj}(\mathbf{x}_i) = \left[</span>
<span class="sd">                                \begin{array}{cc} </span>
<span class="sd">                                    \mathbf{R}_i &amp; 0 \\</span>
<span class="sd">                                    0 &amp; 1</span>
<span class="sd">                                \end{array}</span>
<span class="sd">                             \right] \in \mathbb{R}^{4\times4}</span>

<span class="sd">        where,</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{x}_i = \left[</span>
<span class="sd">                                \begin{array}{cc} </span>
<span class="sd">                                    s_i\mathbf{R}_i &amp; 0 \\</span>
<span class="sd">                                    0 &amp; 1</span>
<span class="sd">                                \end{array}</span>
<span class="sd">                             \right] \in \mathrm{RxSO(3)}</span>

<span class="sd">        In the case of :math:`\textrm{RxSO3}` group, the adjoint transformation is the same as</span>
<span class="sd">        the rotation matrix of the group i.e. the :math:`\textrm{SO3}` part of the group.</span>

<span class="sd">    Note:</span>
<span class="sd">        The adjoint operator is a linear map which moves an element</span>
<span class="sd">        :math:`\mathbf{p} \in \mathcal{g}` in the right tangent space of</span>
<span class="sd">        :math:`\mathbf{x} \in \mathcal{G}` to the left tangent space.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{Exp}(\mathrm{Adj}(\mathbf{x}) \mathbf{p}) * \mathbf{x} </span>
<span class="sd">            = \mathbf{x} * \mathrm{Exp}(\mathbf{p})</span>
<span class="sd">        </span>
<span class="sd">        It can be easily verified:</span>

<span class="sd">            &gt;&gt;&gt; x, p = pp.randn_SO3(), pp.randn_so3()</span>
<span class="sd">            &gt;&gt;&gt; torch.allclose(x*p.Exp(), x.Adj(p).Exp()*x)</span>
<span class="sd">            True</span>
<span class="sd">        </span>
<span class="sd">        One can refer to Eq. (8) of the following paper:</span>

<span class="sd">        * Zachary Teed et al., `Tangent Space Backpropagation for 3D Transformation Groups</span>
<span class="sd">          &lt;https://arxiv.org/pdf/2103.12032.pdf&gt;`_, IEEE/CVF Conference on Computer Vision</span>
<span class="sd">          and Pattern Recognition (CVPR), 2021.</span>

<span class="sd">    Note:</span>
<span class="sd">        :math:`\mathrm{Adj}` is generally used to transform a tangent vector from the tangent</span>
<span class="sd">        space around one element to the tangent space of another.</span>
<span class="sd">        One can refer to this paper for more details:</span>

<span class="sd">        * J. Sola et al., `A micro Lie theory for state estimation in</span>
<span class="sd">          robotics &lt;https://arxiv.org/abs/1812.01537&gt;`_, arXiv preprint arXiv:1812.01537 (2018).</span>

<span class="sd">        The following thesis and the tutorial serve as a good reading material to learn more</span>
<span class="sd">        about deriving the adjoint matrices for different transformation groups. </span>

<span class="sd">        * Strasdat, H., 2012. `Local accuracy and global consistency for efficient visual SLAM</span>
<span class="sd">          &lt;https://www.doc.ic.ac.uk/~ajd/Publications/Strasdat-H-2012-PhD-Thesis.pdf&gt;`_, </span>
<span class="sd">          (Doctoral dissertation, Department of Computing, Imperial College London).</span>

<span class="sd">        * `Lie Groups for 2D and 3D Transformations.</span>
<span class="sd">          &lt;https://www.ethaneade.org/lie.pdf&gt;`_, by Ethan Eade.</span>

<span class="sd">    Example:</span>

<span class="sd">        * :math:`\mathrm{Adj}`: (:obj:`SO3`, :obj:`so3`) :math:`\mapsto` :obj:`so3`</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_SO3(2)</span>
<span class="sd">            &gt;&gt;&gt; p = pp.randn_so3(2)</span>
<span class="sd">            &gt;&gt;&gt; x.Adj(p) # equivalent to: pp.Adj(x, p)</span>
<span class="sd">            so3Type LieTensor:</span>
<span class="sd">            tensor([[-0.4171,  2.1218,  0.9951],</span>
<span class="sd">                    [ 1.8415, -1.2185, -0.4082]])</span>

<span class="sd">        * :math:`\mathrm{Adj}`: (:obj:`SE3`, :obj:`se3`) :math:`\mapsto` :obj:`se3`</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_SE3(2)</span>
<span class="sd">            &gt;&gt;&gt; p = pp.randn_se3(2)</span>
<span class="sd">            &gt;&gt;&gt; x.Adj(p) # equivalent to: pp.Adj(x, p)</span>
<span class="sd">            se3Type LieTensor:</span>
<span class="sd">            tensor([[-0.8536, -0.1984, -0.4554, -0.4868,  0.3231,  0.8535],</span>
<span class="sd">                    [ 0.1577, -1.7625,  1.7997, -1.5085, -0.2098,  0.3538]])</span>

<span class="sd">        * :math:`\mathrm{Adj}`: (:obj:`Sim3`, :obj:`sim3`) :math:`\mapsto` :obj:`sim3`</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_Sim3(2)</span>
<span class="sd">            &gt;&gt;&gt; p = pp.randn_sim3(2)</span>
<span class="sd">            &gt;&gt;&gt; x.Adj(p) # equivalent to: pp.Adj(x, p)</span>
<span class="sd">            sim3Type LieTensor:</span>
<span class="sd">            tensor([[ 0.1455, -0.5653, -0.1845,  0.0502,  1.3125,  1.5217, -0.8964],</span>
<span class="sd">                    [-4.8724, -0.5254,  3.9559,  1.5170,  1.7610,  0.4375,  0.4248]])</span>

<span class="sd">        * :math:`\mathrm{Adj}`: (:obj:`RxSO3`, :obj:`rxso3`) :math:`\mapsto` :obj:`rxso3`</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_RxSO3(2)</span>
<span class="sd">            &gt;&gt;&gt; p = pp.randn_rxso3(2)</span>
<span class="sd">            &gt;&gt;&gt; x.Adj(p) # equivalent to: pp.Adj(x, p)</span>
<span class="sd">            rxso3Type LieTensor:</span>
<span class="sd">            tensor([[-1.3590, -0.4314, -0.0297,  1.0166],</span>
<span class="sd">                    [-0.3378, -0.4942, -2.0083, -0.4321]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">input</span><span class="o">.</span><span class="n">Adj</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdjT"><a class="viewcode-back" href="../../../../generated/pypose.AdjT/#pypose.AdjT">[docs]</a><span class="nd">@assert_ltype</span>
<span class="k">def</span> <span class="nf">AdjT</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">AdjT</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></div>


<div class="viewcode-block" id="Jinvp"><a class="viewcode-back" href="../../../../generated/pypose.Jinvp/#pypose.Jinvp">[docs]</a><span class="nd">@assert_ltype</span>
<span class="k">def</span> <span class="nf">Jinvp</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The dot product between left Jacobian inverse at the point given</span>
<span class="sd">    by input (Lie Group) and second point (Lie Algebra).</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{Jinvp}: (\mathcal{G}, \mathcal{g}) \mapsto \mathcal{g}</span>

<span class="sd">    Args:</span>
<span class="sd">        input (LieTensor): the input LieTensor (Lie Group)</span>
<span class="sd">        p (LieTensor): the second LieTensor (Lie Algebra)</span>

<span class="sd">    Return:</span>
<span class="sd">        LieTensor: the output LieTensor (Lie Algebra)</span>

<span class="sd">    .. list-table:: List of supported :math:`\mathrm{Jinvp}` map</span>
<span class="sd">        :widths: 20 20 8 20 20</span>
<span class="sd">        :header-rows: 1</span>

<span class="sd">        * - input :obj:`ltype`</span>
<span class="sd">          - :math:`(\mathcal{G}, \mathcal{g})` (Lie Group, Lie Algebra)</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{g}` (Lie Algebra)</span>
<span class="sd">          - output :obj:`ltype`</span>
<span class="sd">        * - (:obj:`SO3_type`, :obj:`so3_type`)</span>
<span class="sd">          - :math:`(\mathcal{G}\in\mathbb{R}^{*\times4}, \mathcal{g}\in\mathbb{R}^{*\times3})`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times3}`</span>
<span class="sd">          - :obj:`so3_type`</span>
<span class="sd">        * - (:obj:`SE3_type`, :obj:`se3_type`)</span>
<span class="sd">          - :math:`(\mathcal{G}\in\mathbb{R}^{*\times7}, \mathcal{g}\in\mathbb{R}^{*\times6})`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times6}`</span>
<span class="sd">          - :obj:`se3_type`</span>
<span class="sd">        * - (:obj:`Sim3_type`, :obj:`sim3_type`)</span>
<span class="sd">          - :math:`(\mathcal{G}\in\mathbb{R}^{*\times8}, \mathcal{g}\in\mathbb{R}^{*\times7})`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times7}`</span>
<span class="sd">          - :obj:`sim3_type`</span>
<span class="sd">        * - (:obj:`RxSO3_type`, :obj:`rxso3_type`)</span>
<span class="sd">          - :math:`(\mathcal{G}\in\mathbb{R}^{*\times5}, \mathcal{g}\in\mathbb{R}^{*\times4})`</span>
<span class="sd">          - :math:`\mapsto`</span>
<span class="sd">          - :math:`\mathcal{g}\in\mathbb{R}^{*\times4}`</span>
<span class="sd">          - :obj:`rxso3_type`</span>

<span class="sd">    Let the input be (:math:`\mathbf{x}`, :math:`\mathbf{p}`), :math:`\mathbf{y}` be the output.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{y}_i = \mathbf{J}^{-1}_i(\mathbf{x}_i)\mathbf{p}_i,</span>

<span class="sd">        where :math:`\mathbf{J}^{-1}_i(\mathbf{x}_i)` is the inverse of left Jacobian of</span>
<span class="sd">        :math:`\mathbf{x}_i`. </span>

<span class="sd">    * If input (:math:`\mathbf{x}`, :math:`\mathbf{p}`)&#39;s :obj:`ltype` are :obj:`SO3_type`</span>
<span class="sd">      and :obj:`so3_type` (input :math:`\mathbf{x}` is an instance of :meth:`SO3`,</span>
<span class="sd">      :math:`\mathbf{p}` is an instance of :meth:`so3`).</span>
<span class="sd">      Let :math:`\boldsymbol{\phi}_i = \theta_i\mathbf{n}_i` be the corresponding Lie Algebra</span>
<span class="sd">      of :math:`\mathbf{x}_i`, :math:`\boldsymbol{\Phi}_i` be the skew matrix</span>
<span class="sd">      (:meth:`pypose.vec2skew`) of :math:`\boldsymbol{\phi}_i`:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{J}^{-1}_i(\mathbf{x}_i) = \mathbf{I} - \frac{1}{2}\boldsymbol{\Phi}_i +</span>
<span class="sd">            \mathrm{coef}\boldsymbol{\Phi}_i^2</span>

<span class="sd">      where :math:`\mathbf{I}` is the identity matrix with the same dimension as</span>
<span class="sd">      :math:`\boldsymbol{\Phi}_i`, and </span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{coef} =</span>
<span class="sd">                \left\{</span>
<span class="sd">                \begin{array}{ll} </span>
<span class="sd">                    \frac{1}{\theta_i^2} -</span>
<span class="sd">                    \frac{\cos{\frac{\theta_i}{2}}}{2\theta\sin{\frac{\theta_i}{2}}},</span>
<span class="sd">                    \quad \|\theta_i\| &gt; \text{eps}, \\</span>
<span class="sd">                    \frac{1}{12},</span>
<span class="sd">                    \quad \|\theta_i\| \leq \text{eps}</span>
<span class="sd">                \end{array}</span>
<span class="sd">                \right.</span>

<span class="sd">    * If input (:math:`\mathbf{x}`, :math:`\mathbf{p}`)&#39;s :obj:`ltype` are :obj:`SE3_type`</span>
<span class="sd">      and :obj:`se3_type` (input :math:`\mathbf{x}` is an instance of :meth:`SE3`,</span>
<span class="sd">      :math:`\mathbf{p}` is an instance of :meth:`se3`).</span>
<span class="sd">      Let :math:`\boldsymbol{\phi}_i = \theta_i\mathbf{n}_i` be the corresponding Lie Algebra</span>
<span class="sd">      of the SO3 part of :math:`\mathbf{x}_i`, :math:`\boldsymbol{\tau}_i` be the Lie Algebra</span>
<span class="sd">      of the translation part of :math:`\mathbf{x}_i`; :math:`\boldsymbol{\Phi}_i` and</span>
<span class="sd">      :math:`\boldsymbol{\Tau}_i` be the skew matrices, respectively:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{J}^{-1}_i(\mathbf{x}_i) =</span>
<span class="sd">                \left[</span>
<span class="sd">                \begin{array}{cc} </span>
<span class="sd">                    \mathbf{J}_i^{-1}(\boldsymbol{\Phi}_i) &amp; </span>
<span class="sd">                            - \mathbf{J}_i^{-1}(\boldsymbol{\Phi}_i)</span>
<span class="sd">                    \mathbf{Q}_i(\boldsymbol{\tau}_i, \boldsymbol{\phi}_i) </span>
<span class="sd">                        \mathbf{J}_i^{-1}(\boldsymbol{\Phi}_i) \\</span>
<span class="sd">                    \mathbf{0} &amp; \mathbf{J}_i^{-1}(\boldsymbol{\Phi}_i)</span>
<span class="sd">                \end{array}</span>
<span class="sd">                \right]</span>

<span class="sd">        where :math:`\mathbf{J}_i^{-1}(\boldsymbol{\Phi}_i)` is the inverse of left Jacobian</span>
<span class="sd">        of the SO3 part of :math:`\mathbf{x}_i`. </span>
<span class="sd">        :math:`\mathbf{Q}_i(\boldsymbol{\tau}_i, \boldsymbol{\phi}_i)` is </span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{align*}</span>
<span class="sd">                \mathbf{Q}_i(\boldsymbol{\tau}_i, \boldsymbol{\phi}_i) = </span>
<span class="sd">                    \frac{1}{2}\boldsymbol{\Tau}_i &amp;+ c_1</span>
<span class="sd">                (\boldsymbol{\Phi_i\Tau_i} + \boldsymbol{\Tau_i\Phi_i} </span>
<span class="sd">                    + \boldsymbol{\Phi_i\Tau_i\Phi_i}) \\</span>
<span class="sd">                 &amp;+ c_2 (\boldsymbol{\Phi_i^2\Tau_i} + \boldsymbol{\Tau_i\Phi_i^2} </span>
<span class="sd">                    - 3\boldsymbol{\Phi_i\Tau_i\Phi_i})\\</span>
<span class="sd">                 &amp;+ c_3 (\boldsymbol{\Phi_i\Tau_i\Phi_i^2} + \boldsymbol{\Phi_i^2\Tau_i\Phi_i})  </span>
<span class="sd">            \end{align*}</span>

<span class="sd">        where,</span>

<span class="sd">        .. math::</span>
<span class="sd">            c_1 = \left\{</span>
<span class="sd">                    \begin{array}{ll} </span>
<span class="sd">                        \frac{\theta_i - \sin\theta_i}{\theta_i^3},</span>
<span class="sd">                            \quad \|\theta_i\| &gt; \text{eps}, \\</span>
<span class="sd">                        \frac{1}{6}-\frac{1}{120}\theta_i^2,</span>
<span class="sd">                        \quad \|\theta_i\| \leq \text{eps}</span>
<span class="sd">                    \end{array}</span>
<span class="sd">                    \right.</span>

<span class="sd">        .. math::</span>
<span class="sd">            c_2 = \left\{</span>
<span class="sd">                    \begin{array}{ll} </span>
<span class="sd">                        \frac{\theta_i^2 +2\cos\theta_i - 2}{2\theta_i^4},</span>
<span class="sd">                            \quad \|\theta_i\| &gt; \text{eps}, \\</span>
<span class="sd">                        \frac{1}{24}-\frac{1}{720}\theta_i^2,</span>
<span class="sd">                        \quad \|\theta_i\| \leq \text{eps}</span>
<span class="sd">                    \end{array}</span>
<span class="sd">                    \right.</span>

<span class="sd">        .. math::</span>
<span class="sd">            c_3 = \left\{</span>
<span class="sd">                    \begin{array}{ll} </span>
<span class="sd">                        \frac{2\theta_i - 3\sin\theta_i + \theta_i\cos\theta_i}{2\theta_i^5}, </span>
<span class="sd">                        \quad \|\theta_i\| &gt; \text{eps}, \\</span>
<span class="sd">                        \frac{1}{120}-\frac{1}{2520}\theta_i^2,</span>
<span class="sd">                        \quad \|\theta_i\| \leq \text{eps}</span>
<span class="sd">                    \end{array}</span>
<span class="sd">                    \right.           </span>

<span class="sd">    * If input (:math:`\mathbf{x}`, :math:`\mathbf{p}`)&#39;s :obj:`ltype` are :obj:`Sim3_type`</span>
<span class="sd">      and :obj:`sim3_type` (input :math:`\mathbf{x}` is an instance of :meth:`Sim3`,</span>
<span class="sd">      :math:`\mathbf{p}` is an instance of :meth:`sim3`). The inverse of left Jacobian can</span>
<span class="sd">      be approximated as:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{J}^{-1}_i(\mathbf{x}_i) = </span>
<span class="sd">                \sum_{n=0}(-1)^n\frac{B_n}{n!}(\boldsymbol{\xi}_i^{\curlywedge})^n</span>

<span class="sd">        where :math:`B_n` is the Bernoulli number: :math:`B_0 = 1`, :math:`B_1 = -\frac{1}{2}`,</span>
<span class="sd">        :math:`B_2 = \frac{1}{6}`, :math:`B_3 = 0`, :math:`B_4 = -\frac{1}{30}`.</span>
<span class="sd">        :math:`\boldsymbol{\xi}_i^{\curlywedge} = \mathrm{adj}(\boldsymbol{\xi}_i^{\wedge})`</span>
<span class="sd">        and :math:`\mathrm{adj}` is the adjoint of the Lie algebra :math:`\mathfrak{sim}(3)`,</span>
<span class="sd">        e.g., :math:`\boldsymbol{\xi}_i \in \mathfrak{sim}(3)`. Notice that if notate</span>
<span class="sd">        :math:`\boldsymbol{X}_i = \mathrm{Adj}(\mathbf{x}_i)` and :math:`\mathrm{Adj}` is the</span>
<span class="sd">        adjoint of the Lie group :math:`\mathrm{Sim}(3)`, there is a nice property:</span>
<span class="sd">        :math:`\mathrm{Adj}(\mathrm{Exp}(\boldsymbol{\xi}_i^{\curlywedge})) =</span>
<span class="sd">        \mathrm{Exp}(\mathrm{adj}(\boldsymbol{\xi}_i^{\wedge}))`, </span>
<span class="sd">        or :math:`\boldsymbol{X}_i = \mathrm{Exp}(\boldsymbol{\xi}_i^{\curlywedge})`.</span>
<span class="sd">        </span>

<span class="sd">    * If input (:math:`\mathbf{x}`, :math:`\mathbf{p}`)&#39;s :obj:`ltype` are :obj:`RxSO3_type`</span>
<span class="sd">      and :obj:`rxso3_type` (input :math:`\mathbf{x}` is an instance of :meth:`RxSO3`,</span>
<span class="sd">      :math:`\mathbf{p}` is an instance of :meth:`rxso3`). Let :math:`\boldsymbol{\phi}_i`</span>
<span class="sd">      be the corresponding Lie Algebra of the SO3 part of :math:`\mathbf{x}_i`,</span>
<span class="sd">      :math:`\boldsymbol{\Phi}_i` be the skew matrix (:meth:`pypose.vec2skew`), The inverse</span>
<span class="sd">      of left Jacobian of :math:`\mathbf{x}_i` is the same as that for the SO3 part of</span>
<span class="sd">      :math:`\mathbf{x}_i`.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{J}^{-1}_i(\mathbf{x}_i) = \left[</span>
<span class="sd">                                \begin{array}{cc} </span>
<span class="sd">                                    \mathbf{J}_i^{-1}(\boldsymbol{\Phi}_i) &amp; \mathbf{0} \\</span>
<span class="sd">                                    \mathbf{0} &amp; 1</span>
<span class="sd">                                \end{array}</span>
<span class="sd">                             \right]</span>

<span class="sd">        where :math:`\mathbf{J}_i^{-1}(\boldsymbol{\Phi}_i)` is the</span>
<span class="sd">        inverse of left Jacobian of the SO3 part of :math:`\mathbf{x}_i`.</span>

<span class="sd">    Note:</span>
<span class="sd">        :math:`\mathrm{Jinvp}` is usually used in the Baker-Campbell-Hausdorff formula</span>
<span class="sd">        (BCH formula) when performing LieTensor multiplication.</span>
<span class="sd">        One can refer to this paper for more details:</span>

<span class="sd">        * J. Sola et al., `A micro Lie theory for state estimation in</span>
<span class="sd">          robotics &lt;https://arxiv.org/abs/1812.01537&gt;`_, arXiv preprint arXiv:1812.01537 (2018).</span>

<span class="sd">        In particular, Eq. (146) is the math used in the :obj:`SO3_type`, :obj:`so3_type` scenario; </span>
<span class="sd">        Eq. (179b) and Eq. (180) are the math used in the :obj:`SE3_type`, :obj:`se3_type` scenario.</span>

<span class="sd">        For Lie groups such as :obj:`Sim3_type`, :obj:`sim3_type`,</span>
<span class="sd">        there is no analytic expression for the left Jacobian and its inverse. </span>
<span class="sd">        Numerical approximation is used based on series expansion.</span>
<span class="sd">        One can refer to Eq. (26) of this paper for more details about the approximation:</span>

<span class="sd">        * Z. Teed et al., `Tangent Space Backpropagation for 3D Transformation Groups.</span>
<span class="sd">          &lt;https://arxiv.org/pdf/2103.12032.pdf&gt;`_, in IEEE/CVF Conference on Computer Vision and</span>
<span class="sd">          Pattern Recognition (CVPR) (2021).</span>

<span class="sd">        In particular, the Bernoulli numbers can be obtained from Eq. (7.72) of this famous book:</span>

<span class="sd">        * T. Barfoot, `State Estimation for Robotics.</span>
<span class="sd">          &lt;https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.708.1086&amp;rep=rep1&amp;type=pdf&gt;`_,</span>
<span class="sd">          Cambridge University Press (2017).</span>

<span class="sd">    Example:</span>

<span class="sd">        * :math:`\mathrm{Jinvp}`: (:obj:`SO3`, :obj:`so3`) :math:`\mapsto` :obj:`so3`</span>

<span class="sd">        &gt;&gt;&gt; x = pp.randn_SO3()</span>
<span class="sd">        &gt;&gt;&gt; p = pp.randn_so3()</span>
<span class="sd">        &gt;&gt;&gt; x.Jinvp(p) # equivalent to: pp.Jinvp(x, p)</span>
<span class="sd">        so3Type LieTensor:</span>
<span class="sd">        tensor([-2.0248,  1.1116, -0.0251])</span>

<span class="sd">        * :math:`\mathrm{Jinvp}`: (:obj:`SE3`, :obj:`se3`) :math:`\mapsto` :obj:`se3`</span>

<span class="sd">        &gt;&gt;&gt; x = pp.randn_SE3(2)</span>
<span class="sd">        &gt;&gt;&gt; p = pp.randn_se3(2)</span>
<span class="sd">        &gt;&gt;&gt; x.Jinvp(p) # equivalent to: pp.Jinvp(x, p)</span>
<span class="sd">        se3Type LieTensor:</span>
<span class="sd">        tensor([[ 0.4304,  2.0565,  1.0256,  0.0666, -0.2252, -0.7425],</span>
<span class="sd">                [-0.9317, -1.7806,  0.8660, -2.0028,  0.6098, -0.6517]])</span>

<span class="sd">        * :math:`\mathrm{Jinvp}`: (:obj:`Sim3`, :obj:`sim3`) :math:`\mapsto` :obj:`sim3`</span>

<span class="sd">        &gt;&gt;&gt; x = pp.randn_Sim3(2)</span>
<span class="sd">        &gt;&gt;&gt; p = pp.randn_sim3(2)</span>
<span class="sd">        &gt;&gt;&gt; x.Jinvp(p) # equivalent to: pp.Jinvp(x, p)</span>
<span class="sd">        sim3Type LieTensor:</span>
<span class="sd">        tensor([[-1.7231, -1.6650, -0.0202, -0.3731,  0.8441, -0.5438,  0.2879],</span>
<span class="sd">                [ 0.9965,  0.6337, -0.7320, -0.1874,  0.6312,  0.3919,  0.6938]])</span>

<span class="sd">        * :math:`\mathrm{Jinvp}`: (:obj:`RxSO3`, :obj:`rxso3`) :math:`\mapsto` :obj:`rxso3`</span>

<span class="sd">        &gt;&gt;&gt; x = pp.randn_RxSO3(2)</span>
<span class="sd">        &gt;&gt;&gt; p = pp.randn_rxso3(2)</span>
<span class="sd">        &gt;&gt;&gt; x.Jinvp(p) # equivalent to: pp.Jinvp(x, p)</span>
<span class="sd">        rxso3Type LieTensor:</span>
<span class="sd">        tensor([[ 0.9308, -1.4965, -0.1347,  0.4894],</span>
<span class="sd">                [ 0.6558,  1.2221, -0.8190,  0.2108]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">input</span><span class="o">.</span><span class="n">Jinvp</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></div>


<div class="viewcode-block" id="Jr"><a class="viewcode-back" href="../../../../generated/pypose.Jr/#pypose.Jr">[docs]</a><span class="nd">@assert_ltype</span>
<span class="k">def</span> <span class="nf">Jr</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The batched right Jacobian of a LieTensor.</span>

<span class="sd">    Args:</span>
<span class="sd">        input (LieTensor): the input LieTensor (either Lie Group or Lie Algebra)</span>

<span class="sd">    Return:</span>
<span class="sd">        Tensor: the right Jocobian Matrices</span>

<span class="sd">    Examples:</span>

<span class="sd">        * :math:`\mathrm{Jr}`: :meth:`so3` :math:`\mapsto` :math:`\mathcal{R}^{*\times 3\times 3}`</span>

<span class="sd">            &gt;&gt;&gt; x = pp.randn_so3(requires_grad=True)</span>
<span class="sd">            &gt;&gt;&gt; x.Jr()</span>
<span class="sd">            tensor([[ 0.9289, -0.3053, -0.0895],</span>
<span class="sd">                    [ 0.3180,  0.9082,  0.1667],</span>
<span class="sd">                    [ 0.0104, -0.1889,  0.9757]], grad_fn=&lt;SWhereBackward0&gt;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">Jr</span><span class="p">()</span></div>
</pre></div>

             </article>
             
            </div>
            <footer>
  

  

    <hr>

  

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, PyPose Contributors.

    </p>
  </div>
    
      <div>
        Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
      </div>
     

</footer>

          </div>
        </div>

        <div class="pytorch-content-right" id="pytorch-content-right">
          <div class="pytorch-right-menu" id="pytorch-right-menu">
            <div class="pytorch-side-scroll" id="pytorch-side-scroll-right">
              <a class="twitter-timeline" data-width="280" href="https://twitter.com/pypose_org?ref_src=twsrc%5Etfw">Tweets by pypose_org</a> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
            </div>
          </div>
        </div>
      </section>
    </div>

  


  

     
       <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
         <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
         <script src="../../../../_static/jquery.js"></script>
         <script src="../../../../_static/underscore.js"></script>
         <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
         <script src="../../../../_static/doctools.js"></script>
         <script src="../../../../_static/sphinx_highlight.js"></script>
         <script src="../../../../_static/katex.min.js"></script>
         <script src="../../../../_static/auto-render.min.js"></script>
         <script src="../../../../_static/katex_autorenderer.js"></script>
     

  

  <script type="text/javascript" src="../../../../_static/js/vendor/popper.min.js"></script>
  <script type="text/javascript" src="../../../../_static/js/vendor/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/list.js/1.5.0/list.min.js"></script>
  <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 
<script script type="text/javascript">
  var collapsedSections = ['Developer Notes', 'Language Bindings', 'Libraries', 'Community'];
</script>

<img height="1" width="1" style="border-style:none;" alt="" src="https://www.googleadservices.com/pagead/conversion/795629140/?label=txkmCPmdtosBENSssfsC&amp;guid=ON&amp;script=0"/>


  <!-- Begin Footer -->

  <div class="container-fluid docs-tutorials-resources" id="docs-tutorials-resources">
    <div class="container">
      <div class="row">
        <div class="col-md-4 text-center">
          <h2>Docs</h2>
          <p>Access documentation for PyPose</p>
          <a class="with-right-arrow" href="https://pypose.org/docs/main/index.html">View Docs</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Tutorials</h2>
          <p>Get started with tutorials and examples</p>
          <a class="with-right-arrow" href="https://pypose.org/tutorials">View Tutorials</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Get Started</h2>
          <p>Find resources and how to start using pypose</p>
          <a class="with-right-arrow" href="https://pypose.org/resources">View Resources</a>
        </div>
      </div>
    </div>
  </div>

  <footer class="site-footer">
    <div class="container footer-container">
      <div class="footer-logo-wrapper">
        <a href="https://pypose.org/" class="footer-logo"></a>
      </div>

      <div class="footer-links-wrapper">
        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pypose.org/">Pypose</a></li>
            <li><a href="https://pypose.org/get-started">Get Started</a></li>
            <li><a href="https://pypose.org/features">Features</a></li>
            <li><a href="https://github.com/pypose/pypose/blob/main/CONTRIBUTING.md">Contributing</a></li>
          </ul>
        </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pypose.org/resources">Resources</a></li>
            <li><a href="https://pypose.org/tutorials">Tutorials</a></li>
            <li><a href="https://pypose.org/docs/main/index.html">Docs</a></li>
            <li><a href="https://github.com/pypose/pypose/issues" target="_blank">Github Issues</a></li>
          </ul>
        </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title">Stay up to date</li>
            <li><a href="https://twitter.com/pypose_org" target="_blank">Twitter</a></li>
            <li><a href="https://github.com/pypose/pypose" target="_blank">GitHub</a></li>

          </ul>  
          </div>
        </div>
     </div>

  </footer>

  <div class="cookie-banner-wrapper">
  <div class="container">
    <p class="gdpr-notice">To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or navigating, you agree to allow our usage of cookies. As the current maintainers of this site, Facebooks Cookies Policy applies. Learn more, including about available controls: <a href="https://www.facebook.com/policies/cookies/">Cookies Policy</a>.</p>
    <img class="close-button" src="../../../../_static/images/pytorch-x.svg">
  </div>
</div>

  <!-- End Footer -->

  <!-- Begin Mobile Menu -->

  <div class="mobile-main-menu">
    <div class="container-fluid">
      <div class="container">
        <div class="mobile-main-menu-header-container">
          <a class="header-logo" href="https://pypose.org/" aria-label="PyTorch"></a>
          <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu"></a>
        </div>
      </div>
    </div>

    <div class="mobile-main-menu-links-container">
      <div class="main-menu">
        <ul>
          <li>
            <a href="https://pypose.org/get-started">Get Started</a>
          </li>
          <li>
            <a href="https://pypose.org/tutorials">Tutorials</a>
          </li>
          <li>
            <a href="https://pypose.org/docs/main/index.html">Docs</a>
          </li>
          <li>
            <a href="https://pypose.org/about-us">About Us</a>
          </li>
          <li>
            <a href="https://github.com/pypose/pypose">Github</a>
          </li>
        </ul>
      </div>
    </div>
  </div>

  <!-- End Mobile Menu -->

  <script type="text/javascript" src="../../../../_static/js/vendor/anchor.min.js"></script>

  <script type="text/javascript">
    $(document).ready(function() {
      mobileMenu.bind();
      mobileTOC.bind();
      pytorchAnchors.bind();
      sideMenus.bind();
      scrollToAnchor.bind();
      highlightNavigation.bind();
      mainMenuDropdown.bind();
      filterTags.bind();

      // Add class to links that have code blocks, since we cannot create links in code blocks
      $("article.pytorch-article a span.pre").each(function(e) {
        $(this).closest("a").addClass("has-code");
      });
    })
  </script>
</body>
</html>